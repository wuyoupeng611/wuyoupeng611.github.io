<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Nginx</title>
    <url>/post/65b69107/</url>
    <content><![CDATA[<span id="more"></span>



<h3 id="一-Nginx的介绍"><a href="#一-Nginx的介绍" class="headerlink" title="一.Nginx的介绍"></a>一.Nginx的介绍</h3><ul>
<li>Nginx是一个开源的，支持高性能、高并发的 Web 服务和反向代理服务器。</li>
<li>Nginx使用异步事件驱动的方法来处理请求，Nginx的模块化事件驱动架构可以在高负载下提供更可预测的性能。</li>
<li>Nginx是一款面向性能设计的HTTP服务器，相较于Apache、lighttpd具有占有内存少，稳定性高等优势。</li>
<li>可大量并行处理，Nginx在官方测试的结果中，能够支持五万个并行连接，而在实际的运作中，可以支持二万至四万个并行连接等等。</li>
</ul>
<h3 id="二-Nginx的功能"><a href="#二-Nginx的功能" class="headerlink" title="二.Nginx的功能"></a>二.Nginx的功能</h3><ol>
<li><p>反向代理</p>
<ul>
<li><p>反向代理的作用：隐藏服务器信息 -&gt; 保证内网的安全，通常将反向代理作为公网访问地址，web服务器是内网，即通过nginx配置外网访问web服务器内网。</p>
</li>
<li><p>配置反向代理</p>
<ul>
<li><p>找到nginx配置文件nginx.conf</p>
<ul>
<li><p>docker拉取的nginx，默认配置文件是nginx.conf中引入包含的default.conf文件<br>也就是说nginx.conf配置文件中有如下一个配置</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">include /etc/nginx/conf.d/*.conf;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>修改配置 -&gt; 实现反向代理</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen       80;</span><br><span class="line">    server_name  www.wyp611.com;<span class="comment"># 服务器地址或绑定域名</span></span><br><span class="line"></span><br><span class="line">    location / &#123; <span class="comment"># 访问80端口后的所有路径都转发到 proxy_pass 配置的ip中</span></span><br><span class="line">        root   /usr/share/nginx/html;</span><br><span class="line">        index  index.html index.htm;</span><br><span class="line">           proxy_pass http://wyp611.top; <span class="comment"># 配置反向代理的ip地址和端口号 【注：url地址需加上https://】</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<p>#注意：每次改完nginx配置，都需要出来docker stop nginx  和  docker start nginx才能使配置生效</p>
<pre><code><figure class="highlight asciidoc"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="bullet">- </span>复杂配置 -&gt; 根据不同的后缀名访问不同的服务器地址</span><br><span class="line"></span><br><span class="line"><span class="code">  </span></span><br></pre></td></tr></table></figure>
</code></pre>
</li>
<li><p>负载均衡</p>
<ul>
<li><p>负载均衡介绍</p>
<ul>
<li>Nginx提供的负载均衡策略有2种：内置策略和扩展策略。</li>
<li>内置策略为轮询，加权轮询，Ip hash。扩展策略，就非常多。</li>
</ul>
</li>
<li><p>负载均衡的几种常用方式</p>
<ul>
<li><p>轮询（默认）：每个请求按时间顺序逐一分配到不同的后端服务器，如果后端服务器down掉，能自动剔除。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">upstream backserver &#123;</span><br><span class="line">    server 192.168.0.14;</span><br><span class="line">    server 192.168.0.15;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<p>location / { </p>
<pre><code>  proxy_pass http://backserver;
</code></pre>
<p>}</p>
  <figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- weight：指定轮询几率，weight和访问比率成正比，用于后端服务器性能不均的情况。</span><br><span class="line"></span><br><span class="line">  ```bash</span><br><span class="line">  upstream backserver &#123;</span><br><span class="line">   <span class="built_in"> server </span>192.168.0.14 <span class="attribute">weight</span>=3;</span><br><span class="line">     <span class="built_in"> server </span>192.168.0.15 <span class="attribute">weight</span>=7;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>ip_hash：上述方式存在一个问题就是说，在负载均衡系统中，假如用户在某台服务器上登录了，那么该用户第二次请求的时候，因为我们是负载均衡系统，每次请求都会重新定位到服务器集群中的某一个，那么<strong>已经登录某一个服务器的用户再重新定位到另一个服务器，其登录信息将会丢失，这样显然是不妥的</strong>。我们可以采用<strong>ip_hash</strong>指令解决这个问题，如果客户已经访问了某个服务器，当用户再次访问时，会将该请求通过<strong>哈希算法，自动定位到该服务器，每个请求按访问ip的hash结果分配，这样每个访客固定访问一个后端服务器，可以解决session的问题</strong>。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">  upstream backserver &#123;</span><br><span class="line">      ip_hash;</span><br><span class="line">    server 192.168.0.14:88;</span><br><span class="line">      server 192.168.0.15:80;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>fair：按后端服务器的响应时间来分配请求，响应时间短的优先分配。</p>
<figure class="highlight abnf"><table><tr><td class="code"><pre><span class="line">upstream backserver &#123;</span><br><span class="line">    server server1<span class="comment">;</span></span><br><span class="line">  server server2<span class="comment">;</span></span><br><span class="line">    fair<span class="comment">;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
<li><p>动静分离</p>
<ul>
<li>动静分离是将网站静态资源（HTML，JavaScript，CSS，img等文件）与后台应用分开部署，提高用户访问静态代码的速度，降低对后台应用访问。</li>
<li><strong>动静分离的一种常用做法：</strong>将静态资源部署在nginx上，后台项目部署到应用服务器上，根据一定规则静态资源的请求调度到nginx服务器，达到动静分离的目标。</li>
<li><a href="https://www.cnblogs.com/itzgr/p/13335271.html">Nginx动静分离 </a></li>
</ul>
</li>
</ol>
<h3 id="三-Nginx配置文件结构"><a href="#三-Nginx配置文件结构" class="headerlink" title="三.Nginx配置文件结构"></a>三.Nginx配置文件结构</h3><ol>
<li><p>nginx文件结构</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">...              <span class="comment">#全局块</span></span><br><span class="line"></span><br><span class="line">events &#123;         <span class="comment">#events块</span></span><br><span class="line">   ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">http      <span class="comment">#http块</span></span><br><span class="line">&#123;</span><br><span class="line">    ...   <span class="comment">#http全局块</span></span><br><span class="line">    server        <span class="comment">#server块</span></span><br><span class="line">    &#123; </span><br><span class="line">        ...       <span class="comment">#server全局块</span></span><br><span class="line">        location [PATTERN]   <span class="comment">#location块</span></span><br><span class="line">        &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">        location [PATTERN] </span><br><span class="line">        &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    server</span><br><span class="line">    &#123;</span><br><span class="line">      ...</span><br><span class="line">    &#125;</span><br><span class="line">    ...     <span class="comment">#http全局块</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>全局块</strong>：配置影响nginx全局的指令。一般有运行nginx服务器的用户组，nginx进程pid存放路径，日志存放路径，配置文件引入，允许生成worker process数等。</li>
<li><strong>events块</strong>：配置影响nginx服务器或与用户的网络连接。有每个进程的最大连接数，选取哪种事件驱动模型处理连接请求，是否允许同时接受多个网路连接，开启多个网络连接序列化等。</li>
<li><strong>http块</strong>：可以嵌套多个server，配置代理，缓存，日志定义等绝大多数功能和第三方模块的配置。如文件引入，mime-type定义，日志自定义，是否使用sendfile传输文件，连接超时时间，单连接请求数等。</li>
<li><strong>server块</strong>：配置虚拟主机的相关参数，一个http中可以有多个server。</li>
<li><strong>location块</strong>：配置请求的路由，以及各种页面的处理情况。</li>
</ul>
</li>
<li><p>nginx的基本配置</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">########### 每个指令必须有分号结束。#################</span></span><br><span class="line"><span class="comment">#user administrator administrators;  #配置用户或者组，默认为nobody nobody。</span></span><br><span class="line"><span class="comment">#worker_processes 2;  #允许生成的进程数，默认为1</span></span><br><span class="line"><span class="comment">#pid /nginx/pid/nginx.pid;   #指定nginx进程运行文件存放地址</span></span><br><span class="line">error_log <span class="built_in">log</span>/error.log debug;  <span class="comment">#制定日志路径，级别。这个设置可以放入全局块，http块，server块，级别以此为：debug|info|notice|warn|error|crit|alert|emerg</span></span><br><span class="line">events &#123;</span><br><span class="line">    accept_mutex on;   <span class="comment">#设置网路连接序列化，防止惊群现象发生，默认为on</span></span><br><span class="line">    multi_accept on;  <span class="comment">#设置一个进程是否同时接受多个网络连接，默认为off</span></span><br><span class="line">    <span class="comment">#use epoll;      #事件驱动模型，select|poll|kqueue|epoll|resig|/dev/poll|eventport</span></span><br><span class="line">    worker_connections  1024;    <span class="comment">#最大连接数，默认为512</span></span><br><span class="line">&#125;</span><br><span class="line">http &#123;</span><br><span class="line">    include       mime.types;   <span class="comment">#文件扩展名与文件类型映射表</span></span><br><span class="line">    default_type  application/octet-stream; <span class="comment">#默认文件类型，默认为text/plain</span></span><br><span class="line">    <span class="comment">#access_log off; #取消服务日志    </span></span><br><span class="line">    log_format myFormat <span class="string">&#x27;$remote_addr–$remote_user [$time_local] $request $status $body_bytes_sent $http_referer $http_user_agent $http_x_forwarded_for&#x27;</span>; <span class="comment">#自定义格式</span></span><br><span class="line">    access_log <span class="built_in">log</span>/access.log myFormat;  <span class="comment">#combined为日志格式的默认值</span></span><br><span class="line">    sendfile on;   <span class="comment">#允许sendfile方式传输文件，默认为off，可以在http块，server块，location块。</span></span><br><span class="line">    sendfile_max_chunk 100k;  <span class="comment">#每个进程每次调用传输数量不能大于设定的值，默认为0，即不设上限。</span></span><br><span class="line">    keepalive_timeout 65;  <span class="comment">#连接超时时间，默认为75s，可以在http，server，location块。</span></span><br><span class="line"></span><br><span class="line">    upstream mysvr &#123;   </span><br><span class="line">      server 127.0.0.1:7878;</span><br><span class="line">      server 192.168.10.121:3333 backup;  <span class="comment">#热备</span></span><br><span class="line">    &#125;</span><br><span class="line">    error_page 404 https://www.baidu.com; <span class="comment">#错误页</span></span><br><span class="line">    server &#123;</span><br><span class="line">        keepalive_requests 120; <span class="comment">#单连接请求上限次数。</span></span><br><span class="line">        listen       4545;   <span class="comment">#监听端口</span></span><br><span class="line">        server_name  127.0.0.1;   <span class="comment">#监听地址       </span></span><br><span class="line">        location  ~*^.+$ &#123;       <span class="comment">#请求的url过滤，正则匹配，~为区分大小写，~*为不区分大小写。</span></span><br><span class="line">           <span class="comment">#root path;  #根目录</span></span><br><span class="line">           <span class="comment">#index vv.txt;  #设置默认页</span></span><br><span class="line">           proxy_pass  http://mysvr;  <span class="comment">#请求转向mysvr 定义的服务器列表</span></span><br><span class="line">           deny 127.0.0.1;  <span class="comment">#拒绝的ip</span></span><br><span class="line">           allow 172.18.5.54; <span class="comment">#允许的ip           </span></span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <categories>
        <category>nginx</category>
      </categories>
      <tags>
        <tag>反向代理</tag>
        <tag>负载均衡</tag>
        <tag>动静分离</tag>
        <tag>配置文件</tag>
      </tags>
  </entry>
  <entry>
    <title>基于springboot的小blog项目</title>
    <url>/post/ed9909aa/</url>
    <content><![CDATA[<span id="more"></span>]]></content>
      <categories>
        <category>item</category>
      </categories>
      <tags>
        <tag>blog</tag>
        <tag>item</tag>
      </tags>
  </entry>
  <entry>
    <title>docker初学</title>
    <url>/post/a3ab2041/</url>
    <content><![CDATA[<span id="more"></span>

<h3 id="一-Docker介绍"><a href="#一-Docker介绍" class="headerlink" title="一.Docker介绍"></a>一.Docker介绍</h3><ul>
<li><p>Docker 是一个开源的应用容器引擎，基于Go语言并遵从 Apache2.0 协议开源。</p>
</li>
<li><p>Docker 可以让开发者打包他们的应用以及依赖包到一个轻量级、可移植的容器中，然后发布到任何流行的 Linux 机器上，也可以实现虚拟化。</p>
</li>
<li><p>容器是完全使用沙箱机制，相互之间不会有任何接口（类似 iPhone 的 app）,更重要的是容器性能开销极低。</p>
</li>
</ul>
<h3 id="二-Docker的应用场景"><a href="#二-Docker的应用场景" class="headerlink" title="二.Docker的应用场景"></a>二.Docker的应用场景</h3><ul>
<li><p>Web 应用的自动化打包和发布。</p>
</li>
<li><p>自动化测试和持续集成、发布。</p>
</li>
<li><p>在服务型环境中部署和调整数据库或其他的后台应用。</p>
</li>
<li><p>从头编译或者扩展现有的 OpenShift 或 Cloud Foundry 平台来搭建自己的 PaaS 环境。</p>
</li>
</ul>
<h3 id="三-Docker的优点"><a href="#三-Docker的优点" class="headerlink" title="三.Docker的优点"></a>三.Docker的优点</h3><ul>
<li><p>Docker 是一个用于开发，交付和运行应用程序的开放平台。</p>
</li>
<li><p>Docker 使您能够将应用程序与基础架构分开，从而可以快速交付软件。</p>
</li>
<li><p>借助 Docker，您可以与管理应用程序相同的方式来管理基础架构。</p>
</li>
<li><p>通过利用 Docker 的方法来快速交付，测试和部署代码，您可以大大减少编写代码和在生产环境中运行代码之间的延迟。</p>
</li>
</ul>
<h3 id="四-Docker的架构"><a href="#四-Docker的架构" class="headerlink" title="四.Docker的架构"></a>四.Docker的架构</h3><ul>
<li><strong>镜像（Image）</strong>：Docker 镜像（Image）就像是一个模版，可以通过这个模版来创建容器服务。</li>
<li><strong>容器（Container）</strong>：镜像（Image）和容器（Container）的关系，就像是面向对象程序设计中的类和实例一样，镜像是静态的定义，容器是镜像运行时的实体。容器可以被创建、启动、停止、删除、暂停等。</li>
<li><strong>仓库（Repository）</strong>：仓库可看成一个代码控制中心，用来保存镜像。</li>
<li>Docker 使用客户端-服务器 (C/S) 架构模式，使用远程API来管理和创建Docker容器。</li>
</ul>
<h3 id="五-镜像命令"><a href="#五-镜像命令" class="headerlink" title="五.镜像命令"></a>五.镜像命令</h3><ul>
<li><p>帮助命令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#帮助命令</span></span><br><span class="line">docker version			<span class="comment">#显示docker的版本信息</span></span><br><span class="line">docker info			<span class="comment">#显示docker的系统信息，包括容器和镜像的数量</span></span><br><span class="line">docker 命令 --<span class="built_in">help</span>		<span class="comment">#帮助命令</span></span><br></pre></td></tr></table></figure></li>
<li><p>镜像命令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#镜像命令</span></span><br><span class="line">docker images			<span class="comment">#查看所有的镜像</span></span><br><span class="line">docker images -aq		<span class="comment">#-a:列出所有镜像，-q:只显示镜像的id</span></span><br><span class="line">docker search mysql --filter=STARS=3000	<span class="comment">#搜索镜像，且STARS大于3000</span></span><br><span class="line">docker pull mysql:tag		<span class="comment">#下载镜像，如果不写tag，默认就是latest</span></span><br><span class="line">docker rmi -f 镜像id		<span class="comment">#删除指定的镜像</span></span><br><span class="line">docker rmi -f $(docker images -aq)	<span class="comment">#删除全部镜像</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="六-容器命令"><a href="#六-容器命令" class="headerlink" title="六.容器命令"></a>六.容器命令</h3><ul>
<li><p>容器命令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run [可选参数] image		<span class="comment">#新建容器并启动</span></span><br><span class="line"><span class="comment">#可选参数说明</span></span><br><span class="line">--name=<span class="string">&quot;Name&quot;</span>		<span class="comment">#容器的名字，用来区分同一个镜像创建的容器</span></span><br><span class="line">-d			<span class="comment">#后台方式运行</span></span><br><span class="line">-it			<span class="comment">#使用交互方式运行，进入容器查看内容</span></span><br><span class="line">-p 8080:8080		<span class="comment">#指定容器端口，主机端口:容器端口</span></span><br><span class="line"></span><br><span class="line">docker run -it 镜像名 /bin/bash		<span class="comment">#启动并进入容器</span></span><br><span class="line">docker run -d 镜像名			<span class="comment">#后台启动容器</span></span><br><span class="line"><span class="built_in">exit</span>			<span class="comment">#容器停止并退回主机</span></span><br><span class="line">ctrl+p+q		<span class="comment">#容器不停止退出</span></span><br><span class="line">docker <span class="built_in">exec</span> -it 容器id /bin/bash	<span class="comment">#进入正在运行的容器，会开启新的终端</span></span><br><span class="line">docker attach 容器id		<span class="comment">#进入容器正在执行的终端，不会启动新的进程</span></span><br><span class="line">docker ps			<span class="comment">#列出当前正在运行的容器</span></span><br><span class="line">docker ps -aq		<span class="comment">#a:列出当前正在运行的容器和历史运行过得，q:只显示容器编号</span></span><br><span class="line">docker rm 容器id		<span class="comment">#删除指定容器，不能删除正在运行的，</span></span><br><span class="line">docker rm -f $(docker ps -aq)	<span class="comment">#强制删除所有容器</span></span><br><span class="line">docker start 容器id		<span class="comment">#启动容器</span></span><br><span class="line">docker restart 容器id		<span class="comment">#重启容器</span></span><br><span class="line">docker stop 容器id		<span class="comment">#停止当前正在运行的容器</span></span><br><span class="line">docker <span class="built_in">kill</span> 容器id		<span class="comment">#强制停止当前容器</span></span><br><span class="line">docker inspect 容器id     <span class="comment">#可以查看容器信息</span></span><br></pre></td></tr></table></figure></li>
<li><p>容器中安装vim</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">在使用docker容器时，有时候里边没有安装vim，敲vim命令时提示说：vim: <span class="built_in">command</span> not found，这个时候就需要安装vim，可是当你敲apt-get install vim命令时，提示：</span><br><span class="line"></span><br><span class="line">          Reading package lists... Done</span><br><span class="line">          Building dependency tree       </span><br><span class="line">          Reading state information... Done</span><br><span class="line">          E: Unable to locate package vim</span><br><span class="line">          这时候需要敲：apt-get update，这个命令的作用是：同步 /etc/apt/sources.list 和 /etc/apt/sources.list.d 中列出的源的索引，这样才能获取到最新的软件包。</span><br><span class="line">  </span><br><span class="line">          等更新完毕以后再敲命令：apt-get install vim命令即可。</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="七-其它常用命令"><a href="#七-其它常用命令" class="headerlink" title="七.其它常用命令"></a>七.其它常用命令</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker logs -tf --tail 10 容器id	<span class="comment">#-tf:显示日志，-tail:显示日志条数</span></span><br><span class="line">docker top 容器id		<span class="comment">#查看容器进程信息</span></span><br><span class="line">docker inspect 容器id		<span class="comment">#查看容器元数据</span></span><br><span class="line">docker cp 容器id:容器内路径 目的的主机路径	<span class="comment">#从容器内拷贝文件到主机</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>docker</category>
      </categories>
      <tags>
        <tag>镜像</tag>
        <tag>容器</tag>
      </tags>
  </entry>
  <entry>
    <title>docker进阶</title>
    <url>/post/abdfa13a/</url>
    <content><![CDATA[<span id="more"></span>

<h3 id="一-数据管理"><a href="#一-数据管理" class="headerlink" title="一. 数据管理"></a>一. 数据管理</h3><h4 id="1-数据管理的介绍"><a href="#1-数据管理的介绍" class="headerlink" title="1. 数据管理的介绍"></a>1. 数据管理的介绍</h4><ul>
<li>通常情况下，我们是不会在容器中存储数据的。我们会挂载一个主机的文件夹作为数据卷到容器中去，该数据卷可以被许多需要访问的容器访问得到。这样做的好处是保证了数据的持久化，也增强来应用的可移植性（不改变容器配置）。</li>
<li>Docker内部以及容器之间管理数据，在容器中管理数据主要有两种方式：即：数据卷（Data volumes）数据卷容器（Data volume containers）。</li>
</ul>
<h4 id="2-数据卷"><a href="#2-数据卷" class="headerlink" title="2. 数据卷"></a>2. 数据卷</h4><ul>
<li><p>数据卷是一个可以供一个或多个使用的特殊目录，可以提供很多有用的特性</p>
<ul>
<li>数据卷可以在容器之间共享和重用</li>
<li>对数据卷的修改会立马生效</li>
<li>对数据卷的更新，不会影响镜像</li>
<li>卷会一直存在，直到没有容器使用</li>
</ul>
</li>
<li><p>挂载目录</p>
<ul>
<li><p>在使用docker run时，加上-v参数可以创建一个数据卷挂载到目标容器中去，也可以多次使用该参数挂载多个数据卷。下面创建一个容器，挂载一个数据卷。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo docker run --name=<span class="built_in">test</span> -it -v /home/test_volume/:/home/<span class="built_in">test</span> centos</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>挂载文件</p>
<ul>
<li><p>从主机挂载单个文件到容器中，这样就可以记录在容器输入过的命令了。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo docker run --rm -it -v ~/.bash_history:/.bash_history ubuntu /bin/bash</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>匿名挂载</p>
<ul>
<li><p>在- v 只写了容器内的路径，没有写容器外的路径</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@wyplinux01 /] docker run -d -P --name=nginx02 -v /etc/nginx nginx</span><br><span class="line">271c26643061b31d3385100dd77aa9fb2bf5f8fdf5d7591304cf946ae5423f8c</span><br><span class="line">root@wyplinux01 /] docker volume ls</span><br><span class="line">DRIVER    VOLUME NAME</span><br><span class="line"><span class="built_in">local</span>     271c26643061b31d3385100dd77aa9fb2bf5f8fdf5d7591304cf946ae5423f8c</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>具名挂载</p>
<ul>
<li><p>所有的 docker 容器内的卷，没有指定目录的情况下都是在 <strong>/var/lib/docker/volumes/xxx/_data</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@wyplinux01 /] docker run -d -P --name=nginx02 -v juming-nginx:/etc/nginx nignx</span><br><span class="line">271c26643061b31d3385100dd77aa9fb2bf5f8fdf5d7591304cf946ae5423f8c</span><br><span class="line">root@wyplinux01 /] docker volume ls</span><br><span class="line">DRIVER    VOLUME NAME</span><br><span class="line"><span class="built_in">local</span>     juming-nginx</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h4 id="3-数据卷容器"><a href="#3-数据卷容器" class="headerlink" title="3. 数据卷容器"></a>3. 数据卷容器</h4><ul>
<li><p>数据卷容器，其实就是一个正常的容器，专门用来提供数据卷供其它容器挂载的。 </p>
</li>
<li><p>我们首先先创建一个数据卷容器使用 <strong>–volumes-from</strong> 参数所挂载数据卷的容器自己并不需要保持在运行状态。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run -d -v /nginx --name=nginx01 nginx</span><br></pre></td></tr></table></figure>

<p>发现创建好的数据卷容器是出于停止运行的状态，因为使用 –volumes-from 参数所挂载数据卷的容器自己并不需要保持在运行状态。然后我们再创建容器挂载这个数据卷。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run -d --volumes-from nginx01 --name=nginx02 nginx</span><br><span class="line">docker run -d --volumes-from nginx01 --name=nginx03 nginx</span><br></pre></td></tr></table></figure>

<p>还可以使用多个 –volumes-from 参数来从多个容器挂载多个数据卷。 也可以从其他已经挂载了数据卷的容器来挂载数据卷。</p>
<p>如果删除了挂载的容器（包括 nginx01、nginx02 和 nginx03），数据卷并不会被自动删除。如果要删除一个数据卷，必须在删除最后一个还挂载着它的容器时使用 docker rm -v 命令来指定同时删除关联的容器， 这可以让用户在容器之间升级和移动数据卷。</p>
</li>
</ul>
<h3 id="二-Dockerfile"><a href="#二-Dockerfile" class="headerlink" title="二. Dockerfile"></a>二. Dockerfile</h3><h4 id="1-基本结构"><a href="#1-基本结构" class="headerlink" title="1. 基本结构"></a>1. 基本结构</h4><ul>
<li><p>Dockerfile 由一行行命令语句组成，并且支持以 # 开头的注释行，一般的，Dockerfile 分为四部分：基础镜像信息、维护者信息、镜像操作指令和容器启动时执行指令。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#基础镜像信息</span></span><br><span class="line">FROM ubuntu</span><br><span class="line"></span><br><span class="line"><span class="comment"># 维护者信息</span></span><br><span class="line">MAINTAINER docker_user [email protected]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 镜像操作指令</span></span><br><span class="line">RUN <span class="built_in">echo</span> <span class="string">&quot;deb http://archive.ubuntu.com/ubuntu/ raring main universe&quot;</span> &gt;&gt; /etc/apt/sources.list</span><br><span class="line">RUN apt-get update &amp;&amp; apt-get install -y nginx</span><br><span class="line">RUN <span class="built_in">echo</span> <span class="string">&quot;\ndaemon off;&quot;</span> &gt;&gt; /etc/nginx/nginx.conf</span><br><span class="line"></span><br><span class="line"><span class="comment"># 容器启动时执行指令</span></span><br><span class="line">CMD /usr/sbin/nginx</span><br></pre></td></tr></table></figure>

<p>其中，一开始必须指明所基于的镜像名称，接下来推荐说明维护者信息。</p>
<p>后面则是镜像操作指令，例如 RUN 指令，RUN 指令将对镜像执行跟随的命令。每运行一条 RUN 指令，镜像添加新的一层，并提交。</p>
<p>最后是 CMD 指令，来指定运行容器时的操作命令。</p>
</li>
</ul>
<h4 id="2-命令参数"><a href="#2-命令参数" class="headerlink" title="2. 命令参数"></a>2. 命令参数</h4><ul>
<li><p>FROM</p>
<figure class="highlight sqf"><table><tr><td class="code"><pre><span class="line">格式为 <span class="keyword">FROM</span> &lt;<span class="built_in">image</span>&gt;或<span class="keyword">FROM</span> &lt;<span class="built_in">image</span>&gt;:&lt;tag&gt;</span><br></pre></td></tr></table></figure>

<p>第一条指令必须为<code>FROM</code> 指令。并且，如果在同一个Dockerfile中创建多个镜像时，可以使用多个<code>FROM</code> 指令（每个镜像一次）。</p>
</li>
<li><p>MAINTAINER</p>
<figure class="highlight applescript"><table><tr><td class="code"><pre><span class="line">格式为 MAINTAINER &lt;<span class="built_in">name</span>&gt;，指定维护者信息。</span><br></pre></td></tr></table></figure></li>
<li><p>RUN</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">格式为 <span class="builtin-name">RUN</span> &lt;command&gt; 或 <span class="builtin-name">RUN</span> [<span class="string">&quot;executable&quot;</span>, <span class="string">&quot;param1&quot;</span>, <span class="string">&quot;param2&quot;</span>]</span><br></pre></td></tr></table></figure>

<p><code>前者将在 shell 终端中运行命令</code> ，即 /bin/sh -c；<code>后者则使用 exec 执行</code> 。指定使用其它终端可以通过第二种方式实现，例如 <code>RUN [&quot;/bin/bash&quot;, &quot;-c&quot;, &quot;echo hello&quot;]。</code></p>
<p>每条 <code>RUN</code> 指令将在当前镜像基础上执行指定命令，并提交为新的镜像。当命令较长时可以使用 \ 来换行。</p>
</li>
<li><p>CMD</p>
<p>支持三种格式</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CMD</span><span class="bash"> [<span class="string">&quot;executable&quot;</span>,<span class="string">&quot;param1&quot;</span>,<span class="string">&quot;param2&quot;</span>] 使用 <span class="built_in">exec</span> 执行，推荐方式；</span></span><br><span class="line"><span class="keyword">CMD</span><span class="bash"> <span class="built_in">command</span> param1 param2 在 /bin/sh 中执行，提供给需要交互的应用；</span></span><br><span class="line"><span class="keyword">CMD</span><span class="bash"> [<span class="string">&quot;param1&quot;</span>,<span class="string">&quot;param2&quot;</span>] 提供给 ENTRYPOINT 的默认参数；</span></span><br></pre></td></tr></table></figure>

<p>指定启动容器时执行的命令，每个 Dockerfile 只能有一条<code>CMD</code> 命令，如果指定了多条命令，只有最后一条会被执行。</p>
<p>如果用户启动容器时候指定了运行的命令，则会覆盖掉 <code>CMD</code> 指定的命令。</p>
</li>
<li><p>EXPOSE</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">EXPOSE <span class="tag">&lt;<span class="name">port</span>&gt;</span> [<span class="tag">&lt;<span class="name">port</span>&gt;</span>...]。</span><br></pre></td></tr></table></figure>

<p>告诉 Docker 服务端容器暴露的端口号，供互联系统使用。在启动容器时需要通过 <code>-P</code> ，Docker 主机会自动分配一个端口转发到指定的端口。</p>
</li>
<li><p>ENV</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">ENV <span class="tag">&lt;<span class="name">key</span>&gt;</span> <span class="tag">&lt;<span class="name">value</span>&gt;</span>。</span><br></pre></td></tr></table></figure>

<p>指定一个环境变量，会被后续 <code>RUN</code> 指令使用，并在容器运行时保持。</p>
<p>例如</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">ENV PG_MAJOR <span class="number">9.3</span></span><br><span class="line">ENV PG_VERSION <span class="number">9.3</span><span class="number">.4</span></span><br><span class="line">RUN curl -SL http://example.com/postgres-$PG_VERSION.tar.xz | tar -xJC /usr/src/postgress &amp;&amp; …</span><br><span class="line">ENV <span class="type">PATH</span> /usr/<span class="keyword">local</span>/postgres-$PG_MAJOR/bin:$<span class="type">PATH</span></span><br></pre></td></tr></table></figure></li>
<li><p>ADD</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">ADD <span class="tag">&lt;<span class="name">src</span>&gt;</span> <span class="tag">&lt;<span class="name">dest</span>&gt;</span>。</span><br></pre></td></tr></table></figure>

<p>该命令将复制指定的内容到容器中。 其中可以是Dockerfile所在目录的一个相对路径；也可以是一个 URL；还可以是一个 tar 文件（自动解压为目录）。</p>
</li>
<li><p>COPY</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">COPY <span class="tag">&lt;<span class="name">src</span>&gt;</span> <span class="tag">&lt;<span class="name">dest</span>&gt;</span>。</span><br></pre></td></tr></table></figure>

<p>复制本地主机的内容（为 Dockerfile 所在目录的相对路径）到容器中。</p>
<p>当使用本地目录为源目录时，推荐使用 COPY。</p>
</li>
<li><p>ENTRYPOINT</p>
<p>两种格式：</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ENTRYPOINT</span><span class="bash"> [<span class="string">&quot;executable&quot;</span>, <span class="string">&quot;param1&quot;</span>, <span class="string">&quot;param2&quot;</span>]</span></span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="bash"> <span class="built_in">command</span> param1 param2（shell中执行）。</span></span><br></pre></td></tr></table></figure>

<p>配置容器启动后执行的命令，并且不可被 <code>docker run</code> 提供的参数覆盖。</p>
<p>每个 Dockerfile 中只能有一个 <code>ENTRYPOINT</code> ，当指定多个时，只有最后一个起效。</p>
</li>
<li><p>VOLUME</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">VOLUME <span class="selector-attr">[<span class="string">&quot;/data&quot;</span>]</span>。</span><br></pre></td></tr></table></figure>

<p>创建一个可以从本地主机或其他容器挂载的挂载点，一般用来存放数据库和需要保持的数据等。    </p>
</li>
<li><p>USER</p>
<figure class="highlight crmsh"><table><tr><td class="code"><pre><span class="line"><span class="keyword">USER</span> <span class="title">daemon</span>。</span><br></pre></td></tr></table></figure>

<p>指定运行容器时的用户名或 UID，后续的 RUN 也会使用指定用户。</p>
<p>当服务不需要管理员权限时，可以通过该命令指定运行用户。并且可以在之前创建所需要的用户，例如：<code>RUN groupadd -r postgres &amp;&amp; useradd -r -g postgres postgres</code> 。<code>要临时获取管理员权限可以使用 gosu，而不推荐 sudo</code> 。</p>
</li>
<li><p>WORKDIR</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">WORKDIR <span class="regexp">/path/</span>to/workdir。</span><br></pre></td></tr></table></figure>

<p>为后续的 <code>RUN、CMD、ENTRYPOINT</code> 指令配置工作目录。</p>
<p>可以使用多个<code>WORKDIR</code> 指令，后续命令如果参数是相对路径，则会基于之前命令指定的路径。例如</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">WORKDIR</span><span class="bash"> /a</span></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="bash"> b</span></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="bash"> c</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> <span class="built_in">pwd</span></span></span><br></pre></td></tr></table></figure>

<p>则最终路径为 <code>/a/b/c</code> 。</p>
</li>
<li><p>ONBUILD</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">ONBUILD <span class="selector-attr">[INSTRUCTION]</span>。</span><br></pre></td></tr></table></figure>

<p>配置当所创建的镜像作为其它新创建镜像的基础镜像时，所执行的操作指令。</p>
<p>例如，Dockerfile 使用如下的内容创建了镜像 image-A。</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">[...]</span><br><span class="line">ONBUILD ADD . <span class="regexp">/app/</span>src</span><br><span class="line">ONBUILD RUN <span class="regexp">/usr/</span>local<span class="regexp">/bin/</span>python-build --dir <span class="regexp">/app/</span>src</span><br><span class="line">[...]</span><br></pre></td></tr></table></figure>

<p>如果基于 image-A 创建新的镜像时，新的Dockerfile中使用 FROM image-A指定基础镜像时，会自动执行 ONBUILD 指令内容，等价于在后面添加了两条指令。</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">FROM image-A</span><br><span class="line"><span class="comment">#Automatically run the following</span></span><br><span class="line">ADD . <span class="regexp">/app/</span>src</span><br><span class="line">RUN <span class="regexp">/usr/</span>local<span class="regexp">/bin/</span>python-build --dir <span class="regexp">/app/</span>src</span><br></pre></td></tr></table></figure>

<p>使用 ONBUILD 指令的镜像，推荐在标签中注明，例如 <code>ruby:1.9-onbuild</code> 。</p>
</li>
</ul>
<h3 id="三-docker网络"><a href="#三-docker网络" class="headerlink" title="三. docker网络"></a>三. docker网络</h3><h4 id="1-外部访问容器"><a href="#1-外部访问容器" class="headerlink" title="1. 外部访问容器"></a>1. 外部访问容器</h4><ul>
<li><p>容器中可以运行一些网络应用，要让外部也可以访问这些应用，可以通过 <code>-P</code> 或 <code>-p</code> 参数来指定端口映射。</p>
<p>当使用 <code>-P</code> 标记时，Docker 会随机映射一个端口到内部容器开放的网络端口。</p>
<p><code>-p</code> 则可以指定要映射的端口，并且，在一个指定端口上只可以绑定一个容器。支持的格式有 <code>ip:hostPort:containerPort | ip::containerPort | hostPort:containerPort</code>。</p>
</li>
<li><p><strong>映射所有接口地址</strong></p>
<p>使用 <code>hostPort:containerPort</code> 格式，本地的 80 端口映射到容器的 80 端口，可以执行</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">$ docker <span class="builtin-name">run</span> -d -p 80:80 nginx:alpine</span><br></pre></td></tr></table></figure></li>
<li><p><strong>映射到指定地址的指定端口</strong></p>
<p>可以使用 <code>ip:hostPort:containerPort</code> 格式指定映射使用一个特定地址，比如 localhost 地址 127.0.0.1</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">$ docker <span class="builtin-name">run</span> -d -p 127.0.0.1:80:80 nginx:alpine</span><br></pre></td></tr></table></figure></li>
<li><p><strong>映射到指定地址的任意端口</strong></p>
<p>使用 <code>ip::containerPort</code> 绑定 localhost 的任意端口到容器的 80 端口，本地主机会自动分配一个端口。</p>
<figure class="highlight dns"><table><tr><td class="code"><pre><span class="line">$ docker run -d -p <span class="number">127.0.0.1</span><span class="number">::80</span> nginx:alpine</span><br></pre></td></tr></table></figure>

<p>还可以使用 <code>udp</code> 标记来指定 <code>udp</code> 端口</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">$ docker <span class="builtin-name">run</span> -d -p 127.0.0.1:80:80/udp nginx:alpine</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="2-容器互联"><a href="#2-容器互联" class="headerlink" title="2. 容器互联"></a>2. 容器互联</h4><ul>
<li><p>在以前使用<code>docker</code>，习惯使用 <code>--link</code> 参数来使容器互联，而现在随着 Docker 网络的完善，强烈建议大家将容器加入自定义的 Docker 网络来连接多个容器，而不是使用 <code>--link</code> 参数。</p>
</li>
<li><p><strong>新建网络</strong></p>
<p>下面先创建一个新的 Docker 网络。</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">$ docker<span class="built_in"> network </span>create -d<span class="built_in"> bridge </span>my-net</span><br></pre></td></tr></table></figure>

<p><code>-d</code> 参数指定 Docker 网络类型，有 <code>bridge</code> 、<code>overlay</code>。</p>
</li>
<li><p><strong>连接容器</strong></p>
<p>运行一个容器并连接到新建的 <code>my-net</code> 网络</p>
<figure class="highlight stata"><table><tr><td class="code"><pre><span class="line">$ docker <span class="keyword">run</span> -it --<span class="keyword">rm</span> --name busybox1 --network my-<span class="keyword">net</span> busybox <span class="keyword">sh</span></span><br></pre></td></tr></table></figure>

<p>打开新的终端，再运行一个容器并加入到 <code>my-net</code> 网络</p>
<figure class="highlight stata"><table><tr><td class="code"><pre><span class="line">$ docker <span class="keyword">run</span> -it --<span class="keyword">rm</span> --name busybox2 --network my-<span class="keyword">net</span> busybox <span class="keyword">sh</span></span><br></pre></td></tr></table></figure>

<p>再打开一个新的终端查看容器信息</p>
<figure class="highlight mipsasm"><table><tr><td class="code"><pre><span class="line">$ docker container ls</span><br><span class="line">CONTAINER ID      IMAGE            COMMAND         CREATED          STATUS           PORTS       NAMES <span class="keyword">b47060aca56b </span>     <span class="keyword">busybox </span>          <span class="string">&quot;sh&quot;</span>        <span class="number">11</span> minutes ago   Up <span class="number">11</span> minutes                  <span class="keyword">busybox2 </span><span class="number">8720575823</span>ec      <span class="keyword">busybox </span>          <span class="string">&quot;sh&quot;</span>        <span class="number">16</span> minutes ago   Up <span class="number">16</span> minutes                  <span class="keyword">busybox1 </span></span><br></pre></td></tr></table></figure>

<p>下面通过 <code>ping</code> 来证明 <code>busybox1</code> 容器和 <code>busybox2</code> 容器建立了互联关系。</p>
<p>在 <code>busybox1</code> 容器输入以下命令</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">/ #<span class="built_in"> ping </span>busybox2</span><br><span class="line">PING busybox2 (172.19.0.3): 56 data bytes</span><br><span class="line">64 bytes <span class="keyword">from</span> 172.19.0.3: <span class="attribute">seq</span>=0 <span class="attribute">ttl</span>=64 <span class="attribute">time</span>=0.072 ms</span><br><span class="line">64 bytes <span class="keyword">from</span> 172.19.0.3: <span class="attribute">seq</span>=1 <span class="attribute">ttl</span>=64 <span class="attribute">time</span>=0.118 ms</span><br></pre></td></tr></table></figure>

<p>用 ping 来测试连接 <code>busybox2</code> 容器，它会解析成 <code>172.19.0.3</code>。</p>
<p>同理在 <code>busybox2</code> 容器执行 <code>ping busybox1</code>，也会成功连接到。</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">/ #<span class="built_in"> ping </span>busybox1</span><br><span class="line">PING busybox1 (172.19.0.2): 56 data bytes</span><br><span class="line">64 bytes <span class="keyword">from</span> 172.19.0.2: <span class="attribute">seq</span>=0 <span class="attribute">ttl</span>=64 <span class="attribute">time</span>=0.064 ms</span><br><span class="line">64 bytes <span class="keyword">from</span> 172.19.0.2: <span class="attribute">seq</span>=1 <span class="attribute">ttl</span>=64 <span class="attribute">time</span>=0.143 ms</span><br></pre></td></tr></table></figure>

<p>这样，<code>busybox1</code> 容器和 <code>busybox2</code> 容器建立了互联关系。</p>
</li>
</ul>
<h4 id="3-docker0"><a href="#3-docker0" class="headerlink" title="3. docker0"></a>3. docker0</h4><ul>
<li><p>docker 服务默认会创建一个 <code>docker0</code> 网桥（其上有一个 <code>docker0</code> 内部接口），它在内核层连通了其他的物理或虚拟网卡，这就将所有容器和本地主机都放到同一个物理网络。</p>
<p>由于目前 Docker 网桥是 Linux 网桥，用户可以使用 <code>brctl show</code> 来查看网桥和端口连接信息。</p>
<figure class="highlight mipsasm"><table><tr><td class="code"><pre><span class="line">$ sudo <span class="keyword">brctl </span><span class="keyword">show</span></span><br><span class="line"><span class="keyword">bridge </span>name     <span class="keyword">bridge </span>id               STP enabled     interfaces</span><br><span class="line">docker0         <span class="number">8000</span>.<span class="number">3</span>a1d<span class="symbol">7362b</span>4ee       no              veth<span class="symbol">65f</span>9</span><br><span class="line">                                             			vethdda6</span><br></pre></td></tr></table></figure>

<p>每次创建一个新容器的时候，Docker 从可用的地址段中选择一个空闲的 IP 地址分配给容器的 eth0 （容器内部的网卡，和docker0上的是一对）端口。使用本地主机上 <code>docker0</code> 接口的 IP 作为所有容器的默认网关。</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">$ sudo docker <span class="builtin-name">run</span> -i -t --rm base /bin/bash</span><br><span class="line">$<span class="built_in"> ip </span>addr show eth0</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>docker</category>
      </categories>
      <tags>
        <tag>目录挂载</tag>
        <tag>dockerfile</tag>
        <tag>docker网络</tag>
      </tags>
  </entry>
  <entry>
    <title>docker高级</title>
    <url>/post/20caa7eb/</url>
    <content><![CDATA[<span id="more"></span>]]></content>
      <categories>
        <category>docker</category>
      </categories>
      <tags>
        <tag>docker</tag>
        <tag>高级用法</tag>
      </tags>
  </entry>
  <entry>
    <title>git</title>
    <url>/post/518e617c/</url>
    <content><![CDATA[<span id="more"></span>

<h3 id="一-Git介绍"><a href="#一-Git介绍" class="headerlink" title="一.Git介绍"></a>一.Git介绍</h3><ul>
<li>Git 是一个开源的分布式版本控制系统，用于敏捷高效地处理任何或小或大的项目。</li>
<li>Git 是 Linus Torvalds 为了帮助管理 Linux 内核开发而开发的一个开放源码的版本控制软件。</li>
<li>Git 与常用的版本控制工具 CVS, Subversion 等不同，它采用了分布式版本库的方式。</li>
</ul>
<h3 id="二-Git工作区、暂存区和版本库"><a href="#二-Git工作区、暂存区和版本库" class="headerlink" title="二.Git工作区、暂存区和版本库"></a>二.Git工作区、暂存区和版本库</h3><ul>
<li><strong>工作区：</strong>就是你在电脑里能看到的目录。</li>
<li><strong>暂存区：</strong>英文叫 stage 或 index。一般存放在 <strong>.git</strong> 目录下的 index 文件（.git/index）中，所以我们把暂存区有时也叫作索引（index）。</li>
<li><strong>版本库：</strong>工作区有一个隐藏目录 <strong>.git</strong>，这个不算工作区，而是 Git 的版本库。</li>
<li>[工作区、版本库中的暂存区和版本库之间的关系](<a href="https://www.runoob.com/git/git-workspace-index-repo.html">Git 工作区、暂存区和版本库 | 菜鸟教程 (runoob.com)</a>)</li>
</ul>
<h3 id="三-Git的工作流程"><a href="#三-Git的工作流程" class="headerlink" title="三.Git的工作流程"></a>三.Git的工作流程</h3><ol>
<li><p>从远程仓库中克隆代码到本地仓库。</p>
</li>
<li><p>从本地仓库中checkout代码，然后进行代码修改。</p>
</li>
<li><p>在提交前先将代码提交到暂存区。</p>
</li>
<li><p>提交到本地仓库，本地仓库中保存需改的各个历史版本。</p>
<p><img data-src="D:\blog\source_posts\git的使用\Snipaste_2021-05-04_21-39-27.png" alt="工作流程"></p>
</li>
</ol>
<h3 id="四-Git的使用"><a href="#四-Git的使用" class="headerlink" title="四.Git的使用"></a>四.Git的使用</h3><h4 id="1-Git的环境配置"><a href="#1-Git的环境配置" class="headerlink" title="1.Git的环境配置"></a>1.Git的环境配置</h4><ul>
<li><p>当安装Git后首先要做的事情是设置用户名称和email地址。</p>
</li>
<li><p>设置用户信息</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git config --global user.name <span class="string">&quot;用户名称&quot;</span></span><br><span class="line">git config --global user.email <span class="string">&quot;email&quot;</span></span><br></pre></td></tr></table></figure></li>
<li><p>查看用户信息</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git config --list</span><br><span class="line">git config user.name</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="2-获取Git仓库"><a href="#2-获取Git仓库" class="headerlink" title="2.获取Git仓库"></a>2.获取Git仓库</h4><p>​    获取Git仓库通常有两种方式：</p>
<ul>
<li>在本地初始化一个Git仓库<ol>
<li>在电脑的任意位置创建一个空目录作为我们的本地Git仓库。</li>
<li>进入这个目录，点击右键打开<strong>Git bash</strong>窗口。</li>
<li>执行命令<strong>git init</strong>，如果在当前目录中看到**.git** 文件夹（此文件夹为隐藏文件夹）)则说明Git仓库创建成功。</li>
</ol>
</li>
<li>从远程仓库克隆<ol>
<li>可以通过Git提供的命令从远程仓库进行克隆，将远程仓库克隆到本地。</li>
<li>命令形式：<strong>git clone 远程Git仓库地址</strong></li>
</ol>
</li>
</ul>
<h4 id="3-本地仓库操作"><a href="#3-本地仓库操作" class="headerlink" title="3.本地仓库操作"></a>3.本地仓库操作</h4><ol>
<li><p>Git工作目录下的<strong>文件</strong>存在两种状态：</p>
<ul>
<li><strong>untracked</strong>未跟踪（未被纳入版本控制）</li>
<li><strong>tracked</strong>已跟踪（被纳入版本控制）<ul>
<li><strong>unmodified</strong>未修改状态</li>
<li><strong>modified</strong>已修改状态</li>
<li><strong>staged</strong>已暂存状态</li>
</ul>
</li>
</ul>
</li>
<li><p>Git的本地仓库基本命令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git status				<span class="comment">#查看文件状态</span></span><br><span class="line">git add 文件名			<span class="comment">#将未跟踪的文件加入暂存区</span></span><br><span class="line">git reset 文件名			<span class="comment">#将暂存区的文件取消暂存</span></span><br><span class="line">git commit -m <span class="string">&quot;日志&quot;</span> 文件名		<span class="comment">#将暂存区的文件修改提交到本地仓库</span></span><br><span class="line">git rm 文件名			<span class="comment">#删除文件</span></span><br><span class="line">git <span class="built_in">log</span>				<span class="comment">#查看日志</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="4-远程仓库的操作"><a href="#4-远程仓库的操作" class="headerlink" title="4.远程仓库的操作"></a>4.远程仓库的操作</h4><ul>
<li>查看远程仓库</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git remote			<span class="comment">#git克隆的仓库服务器的默认名称为origin</span></span><br><span class="line">git remote -v</span><br><span class="line">git remote show origin</span><br></pre></td></tr></table></figure>

<ul>
<li>添加远程仓库</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git remote add &lt;shortname&gt; &lt;url&gt;			<span class="comment">#添加一个新的远程Git仓库，同时指定一个可以引用的简写</span></span><br></pre></td></tr></table></figure>

<ul>
<li>从远程仓库克隆</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> &lt;url&gt;			<span class="comment">#把该Git仓库服务器上的几乎所有数据（包括日志信息、历史记录等）都克隆，而不仅仅是复制工作所需要的文件</span></span><br></pre></td></tr></table></figure>

<ul>
<li>移除无效的远程仓库</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git remote rm &lt;shortname&gt;			<span class="comment">#此命令只是从本地移除远程仓库的记录，并不会真正影响到远程仓库</span></span><br></pre></td></tr></table></figure>

<ul>
<li>从远程仓库中抓取与拉取</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git fetch [remote-name] [branch-name]		<span class="comment">#从远程仓库获取最新版本到本地仓库，不会自动merge</span></span><br><span class="line">git merge [remote-name] [branch-name]</span><br><span class="line">git pull [remote-name] [branch-name]		<span class="comment">#从远程仓库获取最新版本到本地仓库，会自动merge</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#注意：如果当前本地仓库不是从远程仓库克隆，而是本地创建的仓库，并且仓库中存在文件，此时再从远程仓库拉取文件的时候会报错（fatal：refusing to merge unrelated histories），解决此问题可以在 git pull 命令后加入参数 --allow-unrealted-histories</span></span><br></pre></td></tr></table></figure>

<ul>
<li>推送到远程仓库</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git push [remote-name] [branch-name]</span><br></pre></td></tr></table></figure>



<h3 id="五-分支"><a href="#五-分支" class="headerlink" title="五.分支"></a>五.分支</h3><ul>
<li>查看分支</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git branch				<span class="comment">#列出所有本地分支</span></span><br><span class="line">git branch -r			<span class="comment">#列出所有远程分支</span></span><br><span class="line">git brach -a			<span class="comment">#列出所有本地分支和远程分支</span></span><br></pre></td></tr></table></figure>

<ul>
<li>创建分支</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git branch (branchname)</span><br><span class="line"><span class="comment">#当你执行 git init 的时候，默认情况下 Git 就会为你创建 master 分支。如果我们要手动创建一个分支。执行 git branch (branchname) 即可</span></span><br></pre></td></tr></table></figure>

<ul>
<li>切换分支</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git checkout (branchname)</span><br><span class="line"><span class="comment">#当你切换分支的时候，Git 会用该分支的最后提交的快照替换你的工作目录的内容， 所以多个分支不需要多个目录。</span></span><br></pre></td></tr></table></figure>

<ul>
<li>推送至远程仓库分支</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git push (remote-name) (branch-name)</span><br></pre></td></tr></table></figure>

<ul>
<li>合并分支</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git merge</span><br></pre></td></tr></table></figure>

<ul>
<li>删除分支</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git branch -d (branchname)</span><br></pre></td></tr></table></figure>



<p><img data-src="C:\Users\W-Y-P\AppData\Roaming\Typora\typora-user-images\image-20210505215937507.png" alt="image-20210505215937507"></p>
<h3 id="六-标签"><a href="#六-标签" class="headerlink" title="六.标签"></a>六.标签</h3><ul>
<li>列出已有的标签</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git tag			<span class="comment">#列出已有标签</span></span><br><span class="line">git show (tagname)			<span class="comment">#查看tag信息</span></span><br></pre></td></tr></table></figure>

<ul>
<li>创建新标签</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git tag -a (tagname)			<span class="comment">#-a 选项意为&quot;创建一个带注解的标签&quot;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>将标签推送至远程仓库</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git push (remote-name) (tag-name)</span><br></pre></td></tr></table></figure>

<ul>
<li>检出标签</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git checkout -b (branch-name) (tag-name)		<span class="comment">#新建一个分支，指向指定标签</span></span><br></pre></td></tr></table></figure>

<ul>
<li>删除标签</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git tag -d (tagname)</span><br><span class="line">git push (remote-name) :refs/tags/(tag-name)</span><br></pre></td></tr></table></figure>









]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
        <tag>命令</tag>
      </tags>
  </entry>
  <entry>
    <title>nosql认识</title>
    <url>/post/d1b72ac1/</url>
    <content><![CDATA[<span id="more"></span>



<h3 id="一-NoSQL的介绍"><a href="#一-NoSQL的介绍" class="headerlink" title="一.NoSQL的介绍"></a>一.NoSQL的介绍</h3><ul>
<li><strong>NoSQL</strong>（<strong>N</strong>ot <strong>o</strong>nly <strong>SQL</strong>），是对不同于传统的<a href="https://zh.wikipedia.org/wiki/%E9%97%9C%E8%81%AF%E5%BC%8F%E8%B3%87%E6%96%99%E5%BA%AB">关系数据库</a>的<a href="https://zh.wikipedia.org/wiki/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F">数据库管理系统</a>的统称。</li>
<li>NoSQL用于超大规模数据的存储。这些类型的数据存储不需要固定的模式，无需多余操作就可以横向扩展。</li>
</ul>
<h3 id="二"><a href="#二" class="headerlink" title="二."></a>二.</h3>]]></content>
      <categories>
        <category>nosql</category>
      </categories>
      <tags>
        <tag>nosql</tag>
        <tag>了解</tag>
        <tag>CAP</tag>
      </tags>
  </entry>
  <entry>
    <title>linux命令总结</title>
    <url>/post/7f49275c/</url>
    <content><![CDATA[<span id="more"></span>



<h4 id="一-帮助和开机等"><a href="#一-帮助和开机等" class="headerlink" title="一.帮助和开机等"></a>一.帮助和开机等</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#帮助命令</span></span><br><span class="line">man 命令或配置文件		<span class="comment">#获取帮助信息</span></span><br><span class="line"><span class="built_in">help</span> 命令			<span class="comment">#获得shell内置命令的帮助信息</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#开机&amp;重启命令</span></span><br><span class="line">shutdown -h now			<span class="comment">#立刻进行关机</span></span><br><span class="line">halt				<span class="comment">#立刻进行关机</span></span><br><span class="line">shutdown -h 1			<span class="comment">#1分钟后关机</span></span><br><span class="line">shutdown -r now			<span class="comment">#现在重启计算机</span></span><br><span class="line">reboot				<span class="comment">#现在重启计算机</span></span><br><span class="line">sync				<span class="comment">#把内存的数据同步到磁盘</span></span><br></pre></td></tr></table></figure>



<h4 id="二-vim"><a href="#二-vim" class="headerlink" title="二.vim"></a>二.vim</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#vim命令(三种模式:一般模式/正常，编辑模式，命令模式)</span></span><br><span class="line">vi				<span class="comment">#文本编辑器</span></span><br><span class="line">vim				<span class="comment">#具有程序编辑的能力，可以看做是vi的增强版本，且在命令行下， :wq(保存退出)  :q(退出)  :q!(强制退出，不保存)</span></span><br><span class="line">yy				<span class="comment">#拷贝当前行	</span></span><br><span class="line">5yy				<span class="comment">#拷贝当前行向下的5行</span></span><br><span class="line">dd				<span class="comment">#删除当前行</span></span><br><span class="line">5dd				<span class="comment">#删除当前行向下的5行</span></span><br><span class="line"><span class="built_in">set</span> nu				<span class="comment">#设置文件的行号</span></span><br><span class="line">/关键字				<span class="comment">#命令行模式下，回车查找，输入n就是查找下一个</span></span><br><span class="line">G/gg				<span class="comment">#在一般模式下，使用快捷键到该文档的最末行/最首行</span></span><br><span class="line">u				<span class="comment">#在一般模式下，撤销这个动作</span></span><br><span class="line">30				<span class="comment">#在一般模式下，输入30，再输入shift+g是移动到30行</span></span><br></pre></td></tr></table></figure>



<h4 id="三-用户-amp-组"><a href="#三-用户-amp-组" class="headerlink" title="三.用户&amp;组"></a>三.用户&amp;组</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#用户&amp;组命令(/etc/passwd:用户的配置文件，/etc/shadow:口令的配置文件，/etc/group:组的配置文件，记录Linux包含的组的信息)</span></span><br><span class="line">groupadd 组名			<span class="comment">#新增组</span></span><br><span class="line">groupdel 组名			<span class="comment">#删除组</span></span><br><span class="line">useradd 用户名			<span class="comment">#添加一个用户(当用户创建成功后，会自动创建和用户同名的家目录)</span></span><br><span class="line">useradd -d 指定目录 用户名	<span class="comment">#给创建的用户指定家目录</span></span><br><span class="line">useradd -g 组名 用户名		<span class="comment">#创建用户时指定组</span></span><br><span class="line">usermod -g 组名 用户名		<span class="comment">#修改用户的组</span></span><br><span class="line">passwd 用户名			<span class="comment">#给用户指定密码</span></span><br><span class="line">userdel 用户名			<span class="comment">#删除用户，但保留家目录</span></span><br><span class="line">userdel -r 用户名		<span class="comment">#删除用户以及家目录</span></span><br><span class="line">chown 用户名 文件名		<span class="comment">#修改文件所有者</span></span><br><span class="line">chgrp 组名 文件名			<span class="comment">#修改文件所在组</span></span><br><span class="line">chmod u=rwx,g=rx,o=x 文件或目录	<span class="comment">#将文件或目录的权限修改成rwx-xr-x</span></span><br><span class="line">chmod 751 文件或目录		<span class="comment">#将文件或目录的权限修改成rwx-xr-x</span></span><br><span class="line">su 用户名			<span class="comment">#切换用户</span></span><br><span class="line">whoami				<span class="comment">#查看当前用户</span></span><br></pre></td></tr></table></figure>



<h4 id="四-文件目录"><a href="#四-文件目录" class="headerlink" title="四.文件目录"></a>四.文件目录</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#文件目录类命令</span></span><br><span class="line"><span class="built_in">pwd</span>				<span class="comment">#显示当前工作目录的绝对路径</span></span><br><span class="line">ls -la 				<span class="comment">#-a显示当前目录所有的文件和目录，包括隐藏的；-l以列表的方式显示信息</span></span><br><span class="line"><span class="built_in">cd</span> ~/..				<span class="comment">#~回到自己的家目录；回到当前目录的上一级目录</span></span><br><span class="line">mkdir [-p] 目录	   		<span class="comment">#创建目录；-p创建多级目录</span></span><br><span class="line">rmdir [-p] 空目录		<span class="comment">#删除空目录；-p顺序删除多级目录</span></span><br><span class="line">touch 文件名称			<span class="comment">#创建一个文件</span></span><br><span class="line">cp [-r] s1 s2			<span class="comment">#将s1拷贝到s2目录下,-r递归复制整个文件夹</span></span><br><span class="line">rm [-rf] 要删除的文件或目录	<span class="comment">#删除的文件或目录，-r递归删除整个文件夹，-f强制删除不提示</span></span><br><span class="line">mv oldName newName		<span class="comment">#重命名</span></span><br><span class="line">mv s1 s2			<span class="comment">#将s1文件或目录移动到s2目录下</span></span><br><span class="line">cat [-n] 文件			<span class="comment">#查看文件内容，-n显示行号，一般会带上管道命令|</span></span><br><span class="line">more 文件			<span class="comment">#ctrl+F：向下滚一屏；ctrl+B：返回上一屏；回车键：向下一行；q：离开more；=：输出当前行号</span></span><br><span class="line">less 文件			<span class="comment">#pagedown：向下翻一页；pageup：向上翻一页；/字串：向下搜索字串功能，n向下查找，N向上查找；q：离开</span></span><br><span class="line"><span class="built_in">echo</span> 输出内容			<span class="comment">#输出内容到控制台，也可以输出环静变量</span></span><br><span class="line">head -n 5 文件			<span class="comment">#查看文件开头的5行，不使用-n就是默认查找文件开头10行</span></span><br><span class="line">tail -n 5 文件			<span class="comment">#查看文件结尾的5行，不使用-n就是默认查找文件结尾10行</span></span><br><span class="line">tail -f 文件			<span class="comment">#实时追踪该文档的所有更新</span></span><br><span class="line">ls -l &gt; 文件			<span class="comment">#列表的内容覆盖写入文件中</span></span><br><span class="line">ls -l &gt;&gt; 文件			<span class="comment">#列表的内容追加写入文件结尾</span></span><br><span class="line"><span class="built_in">history</span> 10			<span class="comment">#显示最近使用过得10个历史命令</span></span><br></pre></td></tr></table></figure>



<h4 id="五-时间日期"><a href="#五-时间日期" class="headerlink" title="五.时间日期"></a>五.时间日期</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#时间日期类命令</span></span><br><span class="line">date <span class="string">&quot;+%Y-%m-%d %H:%M:%S&quot;</span>	<span class="comment">#显示年月日时分秒</span></span><br><span class="line">date -s <span class="string">&quot;2021-04-09 22:00:00&quot;</span>	<span class="comment">#设置系统当前时间</span></span><br><span class="line">cal				<span class="comment">#显示本月日历</span></span><br><span class="line">cal 2021			<span class="comment">#显示2021年日历</span></span><br></pre></td></tr></table></figure>



<h4 id="六-搜索查找"><a href="#六-搜索查找" class="headerlink" title="六.搜索查找"></a>六.搜索查找</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#搜索查找类命令</span></span><br><span class="line">find /home -name s1		<span class="comment">#根据名称递归查找/home目录下的s1文件</span></span><br><span class="line">find /opt -user root		<span class="comment">#查找/opt目录下，用户名为root的文件</span></span><br><span class="line">find / -size +100M		<span class="comment">#查找根目录下大与100M的文件</span></span><br><span class="line">s1 | s2				<span class="comment">#管道符，表示将s1命令处理的结果输出传递给后面的s2命令处理</span></span><br><span class="line">grep -ni <span class="string">&quot;hello&quot;</span> s1		<span class="comment">#在s1文件中查找hello，-n显示匹配行及行号，-i忽略字母大小写</span></span><br><span class="line">cat s1 | grep <span class="string">&quot;hello&quot;</span>		<span class="comment">#在s1文件中查找hello</span></span><br></pre></td></tr></table></figure>



<h4 id="七-压缩-amp-解压"><a href="#七-压缩-amp-解压" class="headerlink" title="七.压缩&amp;解压"></a>七.压缩&amp;解压</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#压缩&amp;解压命令</span></span><br><span class="line">gzip 文件			<span class="comment">#压缩文件</span></span><br><span class="line">gunzip 文件.gz			<span class="comment">#解压.gz文件</span></span><br><span class="line">zip -r 文件或目录			<span class="comment">#-r递归压缩目录及其子文件	</span></span><br><span class="line">unzip -d s1 文件.zip		<span class="comment">#将.zip解压到s1目录下，-d指定解压后文件的目录</span></span><br><span class="line">tar -zcvf s1.tar.gz 文件目录	<span class="comment">#将单个文件或多个文件或目录压缩为s1.tar.gz(-z：打包同时压缩；-c：产生.tar打包文件) </span></span><br><span class="line">tar -zxvf s1.tar.gz		<span class="comment">#将s1.tar.gz解压到当前目录(-x：解包.tar文件；-v：显示详细信息；-f：指定压缩后的文件名) </span></span><br></pre></td></tr></table></figure>



<h4 id="八-任务调度-amp-磁盘"><a href="#八-任务调度-amp-磁盘" class="headerlink" title="八.任务调度&amp;磁盘"></a>八.任务调度&amp;磁盘</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#任务调度</span></span><br><span class="line">crontab -elr			<span class="comment">#-e编辑crontab定时任务；-l查询crontab任务；-r删除当前用户所有的crontab任务，终止任务调度</span></span><br><span class="line">service crond restart		<span class="comment">#重启任务调度</span></span><br><span class="line">at [选项] [时间]			<span class="comment">#一次性定时计划任务</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#磁盘分区&amp;挂载</span></span><br><span class="line">lsblk [-f]			<span class="comment">#查看所有设备挂载情况</span></span><br><span class="line">df -h				<span class="comment">#查询系统整体磁盘使用情况</span></span><br><span class="line">du -hac --max-depth=1 /etc	<span class="comment">#查询/etc目录的磁盘占用情况，深度为1</span></span><br><span class="line">tree 目录			<span class="comment">#以树状显示目录结构</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h4 id="九-进程-amp-管理"><a href="#九-进程-amp-管理" class="headerlink" title="九.进程&amp;管理"></a>九.进程&amp;管理</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#进程&amp;管理命令</span></span><br><span class="line">ps -aux			<span class="comment">#查询所有进程</span></span><br><span class="line">ps -aux | grep X	<span class="comment">#查询有没有x进程</span></span><br><span class="line">ps -ef			<span class="comment">#查询所有进程</span></span><br><span class="line">ps -ef | grep X		<span class="comment">#查询有没有x进程</span></span><br><span class="line"><span class="built_in">kill</span> -9 x		<span class="comment">#强制终止x进程号的进程</span></span><br><span class="line">killall x		<span class="comment">#强制终止x进程名称的进程</span></span><br><span class="line">pstree -pu			<span class="comment">#以树状显示所有进程信息</span></span><br><span class="line">pstree -pu x		<span class="comment">#以树状显示x进程信息(-p:显示进程的pid，-u:显示进程的所属用户)</span></span><br><span class="line">setup				<span class="comment">#查看服务</span></span><br><span class="line">systemctl [start|stop|restart|status] 服务名	<span class="comment">#systemctl管理的服务在/usr/lib/systemd/system</span></span><br><span class="line">systemctl list-unit-files [|服务名] 	<span class="comment">#查看服务开机启动状态</span></span><br><span class="line">systemctl <span class="built_in">enable</span> 服务名		<span class="comment">#设置服务开机启动</span></span><br><span class="line">systemctl <span class="built_in">disable</span> 服务名		<span class="comment">#关闭服务开机启动</span></span><br><span class="line">systemctl is-enabled 服务名	<span class="comment">#查询服务是否是自启动的</span></span><br></pre></td></tr></table></figure>





<h4 id="十-firewall-amp-网络"><a href="#十-firewall-amp-网络" class="headerlink" title="十.firewall&amp;网络"></a>十.firewall&amp;网络</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#firewall命令</span></span><br><span class="line">firewall-cmd --permanent --add-port=端口号/协议	<span class="comment">#打开端口</span></span><br><span class="line">firewall-cmd --permanent --remove-port=端口号/协议	<span class="comment">#关闭端口</span></span><br><span class="line">firewall-cmd --reload		<span class="comment">#重新载入</span></span><br><span class="line">firewall-cmd --query-port=端口号/协议	<span class="comment">#查询端口是否开放</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#监控网络命令</span></span><br><span class="line">netstat -anp [|grep ]	<span class="comment">#查看系统网络情况(-an:按一定顺序排列输出，-p:显示哪个进程在调用)</span></span><br></pre></td></tr></table></figure>





<h4 id="十一-rpm-amp-yum"><a href="#十一-rpm-amp-yum" class="headerlink" title="十一.rpm&amp;yum"></a>十一.rpm&amp;yum</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#rpm&amp;yum命令</span></span><br><span class="line">rpm -qa			<span class="comment">#查询所安装的所有rpm软件包</span></span><br><span class="line">rpm -qa | grep 软件包		<span class="comment">#查询指定的rpm软件包</span></span><br><span class="line">rpm -qi 软件包			<span class="comment">#查询软件包信息</span></span><br><span class="line">rpm -ql 软件包			<span class="comment">#查询软件包中的文件</span></span><br><span class="line">rpm -ivh 软件包			<span class="comment">#安装软件包(i:install安装，v:verbose提示，h:hash进度条)</span></span><br><span class="line">rpm -e 软件包			<span class="comment">#卸载软件包</span></span><br><span class="line">yum install 包名		<span class="comment">#安装指定包</span></span><br><span class="line">yum update 包名		<span class="comment">#更新指定包</span></span><br><span class="line">yum remove 包名		<span class="comment">#删除软件包</span></span><br><span class="line">yum search 包名		<span class="comment">#查找软件包</span></span><br><span class="line">yum list			<span class="comment">#列出所有可安装的软件包清单</span></span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>命令</tag>
      </tags>
  </entry>
  <entry>
    <title>redis初学</title>
    <url>/post/7b25d017/</url>
    <content><![CDATA[<span id="more"></span>

<h3 id="一-redis介绍"><a href="#一-redis介绍" class="headerlink" title="一. redis介绍"></a>一. redis介绍</h3><ul>
<li><p>REmote DIctionary Server(Redis) 是一个 key-value 存储系统，是跨平台的非关系型数据库。</p>
</li>
<li><p>Redis 是一个开源的使用 ANSI C 语言编写、遵守 BSD 协议、支持网络、可基于内存、分布式、可选持久性的键值对(Key-Value)存储数据库，并提供多种语言的 API。</p>
</li>
<li><p>Redis 通常被称为数据结构服务器，因为值（value）可以是字符串(String)、哈希(Hash)、列表(list)、集合(sets)和有序集合(sorted sets)等类型。</p>
</li>
<li><p>Redis 中有5大数据类型，3大特殊数据类型。</p>
</li>
</ul>
<h3 id="二-redis-命令"><a href="#二-redis-命令" class="headerlink" title="二. redis 命令"></a>二. redis 命令</h3><ul>
<li><p>启动 redis 服务器，打开终端并输入命令 <strong>redis-cli</strong>，该命令会连接本地的 redis 服务。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ redis-cli</span><br><span class="line">redis 127.0.0.1:6379&gt;</span><br><span class="line">redis 127.0.0.1:6379&gt; PIN</span><br><span class="line">PONG</span><br></pre></td></tr></table></figure></li>
<li><p>如果需要在远程 redis 服务上执行命令，同样我们使用的也是 <strong>redis-cli</strong> 命令。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ redis-cli -h host -p port -a password</span><br></pre></td></tr></table></figure></li>
<li><p>键的命令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">DEL KEY_NAME		<span class="comment">#删除已存在的键。不存在的 key 会被忽略</span></span><br><span class="line">DUMP KEY_NAME		<span class="comment">#序列化给定的 key ，并返回被序列化的值</span></span><br><span class="line">EXISTS KEY_NAME		<span class="comment">#检查给定 key 是否存在</span></span><br><span class="line">Expire KEY_NAME TIME_IN_SECONDS		<span class="comment">#设置 key 的过期时间，key 过期后将不再可用（单位以秒计）</span></span><br><span class="line">Expireat KEY_NAME UNIX_TIME		<span class="comment">#以 UNIX 时间戳(unix timestamp)格式设置 key 的过期时间</span></span><br><span class="line">PEXPIRE KEY_NAME milliseconds		<span class="comment">#以毫秒为单位设置 key 的生存时间</span></span><br><span class="line">PEXPIREAT KEY_NAME UNIX_milliseconds		<span class="comment">#以 UNIX 时间戳</span></span><br><span class="line">PTTL KEY_NAME		<span class="comment">#以毫秒为单位返回 key 的剩余过期时间</span></span><br><span class="line">TTL KEY_NAME		<span class="comment">#以秒为单位返回 key 的剩余过期时间</span></span><br><span class="line">PERSIST KEY_NAME		<span class="comment">#移除给定 key 的过期时间，使得 key 永不过期</span></span><br><span class="line">KEYS PATTERN		<span class="comment">#查找所有符合给定模式 pattern 的 key </span></span><br><span class="line">MOVE KEY_NAME DB		<span class="comment">#将当前数据库的 key 移动到给定的数据库 db 当中，当前数据库就没有这个 key 了</span></span><br><span class="line">RANDOMKEY		<span class="comment">#从当前数据库中随机返回一个 key</span></span><br><span class="line">RENAME OLD_KEY_NAME NEW_KEY_NAME		<span class="comment">#修改 key 的名称 </span></span><br><span class="line">RENAMENX OLD_KEY_NAME NEW_KEY_NAME		<span class="comment">#在新的 key 不存在时修改 key 的名称</span></span><br><span class="line">TYPE KEY_NAME 		<span class="comment">#返回 key 所储存的值的类型</span></span><br><span class="line">SCAN cursor [MATCH pattern] [COUNT count]		<span class="comment">#迭代数据库中的数据库键，cursor - 游标，pattern - 匹配的模式，count - 指定从数据集里返回多少元素，默认值为 10 ，</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="三-数据类型"><a href="#三-数据类型" class="headerlink" title="三. 数据类型"></a>三. 数据类型</h3><h4 id="1-String（字符串）"><a href="#1-String（字符串）" class="headerlink" title="1. String（字符串）"></a>1. String（字符串）</h4><ul>
<li><p>string 是 redis 最基本的类型，你可以理解成与 Memcached 一模一样的类型，一个 key 对应一个 value。</p>
</li>
<li><p>string 类型是二进制安全的。意思是 redis 的 string 可以包含任何数据。比如jpg图片或者序列化的对象。</p>
</li>
<li><p>string 类型是 Redis 最基本的数据类型，string 类型的值最大能存储 512MB。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">SET KEY_NAME VALUE		<span class="comment">#设置给定 key 的值，如果 key 已经存储其他值， SET 就覆写旧值，且无视类型</span></span><br><span class="line">GET KEY_NAME		<span class="comment">#获取指定 key 的值。如果 key 不存在，返回 nil ，如果key 储存的值不是字符串类型，返回一个错误</span></span><br><span class="line">GETRANGE KEY_NAME start end		<span class="comment">#获取存储在指定 key 中字符串的子字符串</span></span><br><span class="line">SETRANGE KEY_NAME OFFSET VALUE		<span class="comment">#用指定的字符串覆盖给定 key 所储存的字符串值，覆盖的位置从偏移量 offset 开始</span></span><br><span class="line">GETSET KEY_NAME VALUE		<span class="comment">#设置指定 key 的值，并返回 key 的旧值</span></span><br><span class="line">SETNX KEY_NAME VALUE		<span class="comment">#指定的 key 不存在时，为 key 设置指定的值</span></span><br><span class="line">SETEX KEY_NAME TIMEOUT VALUE		<span class="comment">#为指定的 key 设置值及其过期时间。如果 key 已经存在， SETEX 命令将会替换旧的值</span></span><br><span class="line">PSETEX key1 EXPIRY_IN_MILLISECONDS value1		<span class="comment">#以毫秒为单位设置 key 的生存时间</span></span><br><span class="line">STRLEN KEY_NAME			<span class="comment">#获取指定 key 所储存的字符串值的长度</span></span><br><span class="line">MSET key1 value1 key2 value2 .. keyN valueN		<span class="comment">#同时设置一个或多个 key-value 对</span></span><br><span class="line">MGET KEY1 KEY2 .. KEYN		<span class="comment">#返回所有(一个或多个)给定 key 的值</span></span><br><span class="line">MSETNX key1 value1 key2 value2 .. keyN valueN 		<span class="comment">#所有给定 key 都不存在时，同时设置一个或多个 key-value 对</span></span><br><span class="line">INCR KEY_NAME		<span class="comment">#将 key 中储存的数字值增一</span></span><br><span class="line">INCRBY KEY_NAME INCR_AMOUNT		<span class="comment">#将 key 中储存的数字加上指定的增量值</span></span><br><span class="line">INCRBYFLOAT KEY_NAME INCR_AMOUNT		<span class="comment">#为 key 中所储存的值加上指定的浮点数增量值</span></span><br><span class="line">DECR KEY_NAME 		<span class="comment">#将 key 中储存的数字值减一</span></span><br><span class="line">DECRBY KEY_NAME DECREMENT_AMOUNT		<span class="comment">#将 key 所储存的值减去指定的减量值</span></span><br><span class="line">APPEND KEY_NAME NEW_VALUE		<span class="comment">#用于为指定的 key 追加值，如果 key 已经存在并且是一个字符串， APPEND 命令将 value 追加到 key 原来的值的末尾。如果 key 不存在， APPEND 就简单地将给定 key 设为 value ，就像执行 SET key value 一样。</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="2-Hash（哈希）"><a href="#2-Hash（哈希）" class="headerlink" title="2. Hash（哈希）"></a>2. Hash（哈希）</h4><ul>
<li><p>键值对集合,即编程语言中的Map类型。</p>
</li>
<li><p>适合存储对象,并且可以像数据库中update一个属性一样只修改某一项属性值。</p>
</li>
<li><p>使用场景：存储、读取、修改用户属性。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">HSET KEY_NAME FIELD VALUE		<span class="comment">#为哈希表中的字段赋值</span></span><br><span class="line">HSETNX KEY_NAME FIELD VALUE		<span class="comment">#为哈希表中不存在的的字段赋值，如果字段已经存在于哈希表中，操作无效。</span></span><br><span class="line">HGET KEY_NAME FIELD_NAME 		<span class="comment">#返回哈希表中指定字段的值</span></span><br><span class="line">HGETALL KEY_NAME		<span class="comment">#返回哈希表中，所有的字段和值</span></span><br><span class="line">HEXISTS KEY_NAME FIELD_NAME		<span class="comment">#查看哈希表的指定字段是否存在</span></span><br><span class="line">HDEL KEY_NAME FIELD1.. FIELDN		<span class="comment">#用于删除哈希表 key 中的一个或多个指定字段，不存在的字段将被忽略</span></span><br><span class="line">HINCRBY KEY_NAME FIELD_NAME INCR_BY_NUMBER		<span class="comment">#为哈希表中的字段值加上指定增量值</span></span><br><span class="line">HINCRBYFLOAT key field increment		<span class="comment">#为哈希表中的字段值加上指定浮点数增量值，如果不存在，在执行命令前，字段的值被初始化为 0 </span></span><br><span class="line">HKEYS key		<span class="comment">#获取哈希表中的所有域（field）</span></span><br><span class="line">HVALS KEY_NAME FIELD VALUE		<span class="comment">#返回哈希表所有域(field)的值</span></span><br><span class="line">HLEN KEY_NAME 		<span class="comment">#获取哈希表中字段的数量</span></span><br><span class="line">HMGET KEY_NAME FIELD1...FIELDN		<span class="comment">#返回哈希表中，一个或多个给定字段的值</span></span><br><span class="line">HMSET KEY_NAME FIELD1 VALUE1 ...FIELDN VALUEN		<span class="comment">#用于同时将多个 field-value (字段-值)对设置到哈希表中,此命令会覆盖哈希表中已存在的字段。如果哈希表不存在，会创建一个空哈希表，并执行 HMSET 操作</span></span><br><span class="line">HSCAN key cursor [MATCH pattern] [COUNT count]		<span class="comment">#迭代哈希表中的键值对</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="3-List（列表）"><a href="#3-List（列表）" class="headerlink" title="3. List（列表）"></a>3. List（列表）</h4><ul>
<li><p>链表(双向链表)，增删快,提供了操作某一段元素的API。</p>
</li>
<li><p>使用场景：最新消息排行等功能(比如朋友圈的时间线) ；消息队列。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">LPUSH KEY_NAME VALUE1.. VALUEN		<span class="comment">#将一个或多个值插入到列表头部。 如果 key 不存在，一个空列表会被创建并执行</span></span><br><span class="line">LPUSHX KEY_NAME VALUE1.. VALUEN		<span class="comment">#将一个值插入到已存在的列表头部，列表不存在时操作无效</span></span><br><span class="line">Lpop KEY_NAME		<span class="comment">#移除并返回列表的第一个元素</span></span><br><span class="line">LRANGE KEY_NAME START END		<span class="comment">#返回列表中指定区间内的元素，区间以偏移量 START 和 END 指定，可以使用负数下标</span></span><br><span class="line">RPUSH KEY_NAME VALUE1..VALUEN		<span class="comment">#将一个或多个值插入到列表的尾部(最右边)</span></span><br><span class="line">RPUSHX KEY_NAME VALUE		<span class="comment">#将一个值插入到已存在的列表尾部(最右边)。如果列表不存在，操作无效</span></span><br><span class="line">RPOP KEY_NAME		<span class="comment">#用于移除列表的最后一个元素，返回值为移除的元素</span></span><br><span class="line">RPOPLPUSH SOURCE_KEY_NAME DESTINATION_KEY_NAME		<span class="comment">#用于移除列表的最后一个元素，并将该元素添加到另一个列表并返回</span></span><br><span class="line">BLPOP LIST1 ... TIMEOUT		<span class="comment">#移出并获取列表的第一个元素，如果列表没有元素会阻塞列表直到等待超时或发现可弹出元素为止</span></span><br><span class="line">BRPOP LIST1 LIST2 .. LISTN TIMEOUT		<span class="comment">#出并获取列表的最后一个元素,如果列表没有元素..</span></span><br><span class="line">BRPOPLPUSH LIST1 ANOTHER_LIST TIMEOUT		<span class="comment">#从列表中取出最后一个元素，并插入到另外一个列表的头部,如果列表没有元素..</span></span><br><span class="line">LLEN KEY_NAME		<span class="comment">#返回列表的长度。 如果列表 key 不存在，则 key 被解释为一个空列表，返回 0</span></span><br><span class="line">LINDEX KEY_NAME INDEX_POSITION		<span class="comment">#通过索引获取列表中的元素。以 -1 表示列表的最后一个元素，-2 表示列表的倒数第二个</span></span><br><span class="line">LINSERT key BEFORE|AFTER pivot value		<span class="comment">#在列表的元素前或者后插入元素</span></span><br><span class="line">LSET KEY_NAME INDEX VALUE		<span class="comment">#通过索引来设置元素的值</span></span><br><span class="line">LTRIM KEY_NAME START STOP		<span class="comment">#对一个列表进行修剪(trim)，就是说，让列表只保留指定区间内的元素</span></span><br><span class="line">LREM key count VALUE		<span class="comment">#根据参数 COUNT 的值，移除列表中与参数 VALUE 相等的元素</span></span><br><span class="line">							<span class="comment">#count &gt; 0 : 从表头开始向表尾搜索，移除与 VALUE 相等的元素，数量为 COUNT 。</span></span><br><span class="line">							<span class="comment">#count &lt; 0 : 从表尾开始向表头搜索，移除与 VALUE 相等的元素，数量为 COUNT 的绝对值。</span></span><br><span class="line">							<span class="comment">#count = 0 : 移除表中所有与 VALUE 相等的值。</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="4-Set（集合）"><a href="#4-Set（集合）" class="headerlink" title="4. Set（集合）"></a>4. Set（集合）</h4><ul>
<li><p>Redis 的 Set 是 string 类型的无序集合。</p>
</li>
<li><p>集合是通过哈希表实现的，所以添加，删除，查找的复杂度都是 O(1)，为集合提供了求交集、并集、差集等操作。</p>
</li>
<li><p>使用场景：共同好友 ；利用唯一性,统计访问网站的所有独立ip ；好友推荐时,根据tag求交集,大于某个阈值就可以推荐。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">SADD KEY_NAME VALUE1..VALUEN		<span class="comment">#将一个或多个成员元素加入到集合中，已经存在于集合的成员元素将被忽略</span></span><br><span class="line">SCARD KEY_NAME		<span class="comment">#返回集合中元素的数量</span></span><br><span class="line">SISMEMBER KEY VALUE		<span class="comment">#判断成员元素是否是集合的成员</span></span><br><span class="line">SMEMBERS key		<span class="comment">#返回集合中的所有的成员</span></span><br><span class="line">SMOVE SOURCE DESTINATION MEMBER		<span class="comment">#指定成员 member 元素从 source 集合移动到 destination集合,SMOVE是原子性操作</span></span><br><span class="line">SPOP key [count]		<span class="comment">#移除集合中的指定 key 的一个或多个随机元素，移除后会返回移除的元素</span></span><br><span class="line">SRANDMEMBER KEY [count]		<span class="comment">#用于返回集合中的一个随机元素</span></span><br><span class="line">SREM KEY MEMBER1..MEMBERN		<span class="comment">#移除集合中的一个或多个成员元素，不存在的成员元素会被忽略</span></span><br><span class="line">SDIFF FIRST_KEY OTHER_KEY1..OTHER_KEYN		<span class="comment">#返回第一个集合与其他集合之间的差异，也可以认为说第一个集合中独有的元素</span></span><br><span class="line">SINTER KEY KEY1..KEYN		<span class="comment">#返回给定所有给定集合的交集</span></span><br><span class="line">SUNION KEY KEY1..KEYN		<span class="comment">#返回给定集合的并集。不存在的集合 key 被视为空集</span></span><br><span class="line">SUNIONSTORE destination key [key ...]		<span class="comment">#将给定集合的并集存储在指定的集合 destination 中</span></span><br><span class="line">SSCAN key cursor [MATCH pattern] [COUNT count]		<span class="comment">#迭代集合中键的元素</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="5-ZSet（sorted-set：有序集合）"><a href="#5-ZSet（sorted-set：有序集合）" class="headerlink" title="5.ZSet（sorted set：有序集合）"></a>5.ZSet（sorted set：有序集合）</h4><ul>
<li><p>zset 和 set 一样也是string类型元素的集合,且不允许重复的成员。不同的是每个元素都会关联一个double类型的权重参数score。redis正是通过score来为集合中的成员进行从小到大的排序。</p>
</li>
<li><p>数据插入集合时,已经进行天然排序，zset的成员是唯一的,但分数(score)却可以重复。</p>
</li>
<li><p>使用场景：排行榜 ；带权重的消息队列。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ZADD KEY_NAME SCORE1 VALUE1.. SCOREN VALUEN		<span class="comment">#向有序集合添加一个或多个成员，或者更新已存在成员的分数</span></span><br><span class="line">ZCARD KEY_NAME		<span class="comment">#计算集合中元素的数量</span></span><br><span class="line">ZCOUNT key min max		<span class="comment">#计算在有序集合中指定区间分数的成员数</span></span><br><span class="line">ZINCRBY key increment member		<span class="comment">#对有序集合中指定成员的分数加上增量 increment</span></span><br><span class="line">ZINTERSTORE destination numkeys key [key ...] [WEIGHTS weight [weight ...]] [AGGREGATE SUM|MIN|MAX]</span><br><span class="line"><span class="comment">#算给定的一个或多个有序集的交集，其中给定 key 的数量必须以 numkeys 参数指定，并将该交集(结果集)储存到 destination </span></span><br><span class="line">ZLEXCOUNT KEY MIN MAX		<span class="comment">#计算有序集合中指定字典区间内成员数量</span></span><br><span class="line">ZRANGE key start stop [WITHSCORES]		<span class="comment">#返回有序集中，指定区间内的成员</span></span><br><span class="line">ZRANGEBYLEX key min max [LIMIT offset count]		<span class="comment">#通过字典区间返回有序集合的成员</span></span><br><span class="line">ZRANGEBYSCORE key min max [WITHSCORES] [LIMIT offset count]		<span class="comment">#返回有序集合中指定分数区间的成员列表</span></span><br><span class="line">ZRANK key member		<span class="comment">#返回有序集合中指定成员的索引</span></span><br><span class="line">ZREM key member [member ...]		<span class="comment">#移除有序集合中的一个或多个成员，不存在的成员将被忽略</span></span><br><span class="line">ZREMRANGEBYLEX key min max		<span class="comment">#移除有序集合中给定的字典区间的所有成员</span></span><br><span class="line">ZREMRANGEBYRANK key start stop		<span class="comment">#移除有序集中，指定排名(rank)区间内的所有成员</span></span><br><span class="line">ZREMRANGEBYSCORE key min max		<span class="comment">#移除有序集中，指定分数（score）区间内的所有成员</span></span><br><span class="line">ZREVRANGE key start stop [WITHSCORES]		<span class="comment">#返回有序集中，指定区间内的成员，按分数值递减(从大到小)来排列</span></span><br><span class="line">ZREVRANGEBYSCORE key max min [WITHSCORES] [LIMIT offset count]		<span class="comment">#返回有序集中指定分数区间内的所有的成员</span></span><br><span class="line">ZREVRANK key member		<span class="comment">#返回有序集中成员的排名。其中有序集成员按分数值递减(从大到小)排序。</span></span><br><span class="line">ZSCORE key member		<span class="comment">#返回有序集中，成员的分数值。 如果成员元素不是有序集 key 的成员，或 key 不存在，返回 nil</span></span><br><span class="line">ZUNIONSTORE destination numkeys key [key ...] [WEIGHTS weight [weight ...]] [AGGREGATE SUM|MIN|MAX]</span><br><span class="line"><span class="comment">#计算给定的一个或多个有序集的并集，其中给定 key 的数量必须以 numkeys 参数指定，并将该并集(结果集)储存到 destination</span></span><br><span class="line">ZSCAN key cursor [MATCH pattern] [COUNT count]		<span class="comment">#迭代有序集合中的元素（包括元素成员和元素分值）</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="6-Geospatial"><a href="#6-Geospatial" class="headerlink" title="6. Geospatial"></a>6. Geospatial</h4><ul>
<li><p>Redis 的 GEO 特性在 Redis 3.2 版本中推出， 这个功能可以将用户给定的地理位置信息储存起来， 并对这些信息进行操作。</p>
</li>
<li><p>GEO 底层的实现原理其实就是 Zset！我们可以使用Zset命令来操作geo</p>
</li>
<li><p>有效的经度从-180度到180度。</p>
</li>
<li><p>有效的纬度从-85.05112878度到85.05112878度。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">geoadd key longitud(经度) latitude(纬度) member	[member..]	<span class="comment">#将一个/多个具体经纬度的坐标存入一个有序集合</span></span><br><span class="line">geopos key member [member..]		<span class="comment">#获取集合中的一个/多个成员坐标</span></span><br><span class="line">geodist key member1 member2 [unit]		<span class="comment">#返回两个给定位置之间的距离，unit：m、km、mi 英里、ft 英尺</span></span><br><span class="line">georadius key longitude latitude radius m|km|mi|ft [WITHCOORD][WITHDIST] [WITHHASH] [COUNT count]</span><br><span class="line"><span class="comment">#以给定的经纬度为中心， 返回集合包含的位置元素当中， 与中心的距离不超过给定最大距离的所有位置元素</span></span><br><span class="line"><span class="comment">#WITHDIST：在返回位置元素的同时， 将位置元素与中心之间的距离也一并返回</span></span><br><span class="line"><span class="comment">#WITHCOORD：将位置元素的经度和维度也一并返回</span></span><br><span class="line"><span class="comment">#WITHHASH：以 52 位有符号整数的形式， 返回位置元素经过原始 geohash 编码的有序集合分值。这个选项主要用于底层应用或者调试， 实际中的作用并不大。</span></span><br><span class="line">GEORADIUSBYMEMBER key member radius		<span class="comment">#功能与GEORADIUS相同，只是中心位置不是具体的经纬度，而是使用已有的成员</span></span><br><span class="line">geohash key member1 [member..]		<span class="comment">#返回一个或多个位置元素的Geohash表示，使用Geohash位置52点整数编码</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="7-Hyperloglog（基数统计）"><a href="#7-Hyperloglog（基数统计）" class="headerlink" title="7. Hyperloglog（基数统计）"></a>7. Hyperloglog（基数统计）</h4><ul>
<li><p>底层使用string数据类型。</p>
</li>
<li><p>占用的内存是固定，2^64 不同的元素的技术，只需要废 12KB内存。</p>
</li>
<li><p>如果允许容错，那么一定可以使用Hyperloglog ，如果不允许容错，就使用set或者自己的数据类型即可。</p>
</li>
<li><p>使用场景：网页的访问量。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">PFADD key element1 [elememt2..]		<span class="comment">#添加指定元素到 HyperLogLog 中</span></span><br><span class="line">PFCOUNT key [key]		<span class="comment">#返回给定 HyperLogLog 的基数估算值</span></span><br><span class="line">PFMERGE destkey sourcekey [sourcekey..]		<span class="comment">#将多个 HyperLogLog 合并为一个 HyperLogLog</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="8-Bitmap（位图）"><a href="#8-Bitmap（位图）" class="headerlink" title="8. Bitmap（位图）"></a>8. Bitmap（位图）</h4><ul>
<li><p>使用位存储，信息状态只有 0 和 1。</p>
</li>
<li><p>Bitmap是一串连续的2进制数字（0或1），每一位所在的位置为偏移(offset)。</p>
</li>
<li><p>在bitmap上可执行AND,OR,XOR,NOT以及其它位操作。</p>
</li>
<li><p>使用场景：签到统计、状态统计，两个状态的，都可以使用 Bitmaps。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">setbit key offset value		<span class="comment">#为指定key的offset位设置值</span></span><br><span class="line">getbit key offset		<span class="comment">#获取offset位的值</span></span><br><span class="line">bitcount key [start end]		<span class="comment">#统计字符串被设置为1的bit数，也可以指定统计范围按字节</span></span><br><span class="line">bitop operration destkey key[key..]		<span class="comment">#对一个或多个保存二进制位的字符串 key 进行位元操作，并将结果保存到destkey上</span></span><br><span class="line">bitpos key bit [start] [end]		<span class="comment">#返回字符串里面第一个被设置为1或者0的bit位,start和end只能按字节,不能按位</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="四-事务"><a href="#四-事务" class="headerlink" title="四. 事务"></a>四. 事务</h3><h4 id="1-Redis-事务"><a href="#1-Redis-事务" class="headerlink" title="1. Redis 事务"></a>1. Redis 事务</h4><ul>
<li>Redis 事务可以一次执行多个命令， 并且带有以下三个重要的保证：<ul>
<li>批量操作在发送 EXEC 命令前被放入队列缓存。</li>
<li>收到 EXEC 命令后进入事务执行，事务中任意命令执行失败，其余的命令依然被执行。</li>
<li>在事务执行过程，其他客户端提交的命令请求不会插入到事务执行命令序列中。</li>
</ul>
</li>
<li>一个事务从开始到执行会经历以下三个阶段：<ul>
<li>开始事务（<strong>MULTI</strong> ）</li>
<li>命令入队</li>
<li>执行事务（<strong>EXEC</strong> ）</li>
</ul>
</li>
<li>单个 Redis 命令的执行是原子性的，但 Redis 没有在事务上增加任何维持原子性的机制，所以 Redis 事务的执行并不是原子性的。</li>
<li>编译型异常（代码有问题，命令有错），事务中所有的命令都不会被执行。</li>
<li>运行时异常（1 / 0），如果事务队列中存在语法性，那么执行命令的时候，其他命令是可以正常执行的，错误命令跑出异常。</li>
</ul>
<h4 id="2-事务命令"><a href="#2-事务命令" class="headerlink" title="2. 事务命令"></a>2. 事务命令</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">MULTI		<span class="comment">#标记一个事务块的开始</span></span><br><span class="line">DISCARD		<span class="comment">#取消事务，放弃执行事务块内的所有命令</span></span><br><span class="line">EXEC		<span class="comment">#执行所有事务块内的命令</span></span><br><span class="line">WATCH key [key ...]		<span class="comment">#监视一个(或多个) key ，如果在事务执行之前这个(或这些) key 被其他命令所改动，那么事务将被打断，导致事务执行失败，如果发现事务执行失败，就先解锁，在进行监视</span></span><br><span class="line">UNWATCH		<span class="comment">#取消 WATCH 命令对所有 key 的监视</span></span><br></pre></td></tr></table></figure>



<h4 id="3-实例"><a href="#3-实例" class="headerlink" title="3. 实例"></a>3. 实例</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">redis 127.0.0.1:6379&gt; MULTI</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">redis 127.0.0.1:6379&gt; SET name <span class="string">&quot;hello redis&quot;</span></span><br><span class="line">QUEUED</span><br><span class="line"></span><br><span class="line">redis 127.0.0.1:6379&gt; GET name</span><br><span class="line">QUEUED</span><br><span class="line"></span><br><span class="line">redis 127.0.0.1:6379&gt; SADD tag <span class="string">&quot;hello&quot;</span> <span class="string">&quot;redis&quot;</span></span><br><span class="line">QUEUED</span><br><span class="line"></span><br><span class="line">redis 127.0.0.1:6379&gt; SMEMBERS tag</span><br><span class="line">QUEUED</span><br><span class="line"></span><br><span class="line">redis 127.0.0.1:6379&gt; EXEC</span><br><span class="line">1) OK</span><br><span class="line">2) <span class="string">&quot;hello redis&quot;</span></span><br><span class="line">3) (<span class="built_in">integer</span>) 2</span><br><span class="line">4) 1) <span class="string">&quot;hello&quot;</span></span><br><span class="line">   2) <span class="string">&quot;redis&quot;</span></span><br></pre></td></tr></table></figure>





<h3 id="五-Jedis"><a href="#五-Jedis" class="headerlink" title="五. Jedis"></a>五. Jedis</h3><h4 id="1-Jedis-介绍"><a href="#1-Jedis-介绍" class="headerlink" title="1. Jedis 介绍"></a>1. Jedis 介绍</h4><ul>
<li><strong>Jedis</strong> 是 Redis 官方推荐的 java 连接开发工具，使用 java 操作 Redis 的中间件。</li>
</ul>
<h4 id="2-连接-redis-服务"><a href="#2-连接-redis-服务" class="headerlink" title="2. 连接 redis 服务"></a>2. 连接 redis 服务</h4><ul>
<li><p>导入依赖</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>redis.clients<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jedis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.2.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>连接</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestPing</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//连接本地的 Redis 服务</span></span><br><span class="line">        Jedis jedis = <span class="keyword">new</span> Jedis(<span class="string">&quot;localhost&quot;</span>,<span class="number">6379</span>);</span><br><span class="line">        <span class="comment">// 如果 Redis 服务设置了密码，需要下面这行，没有就不需要</span></span><br><span class="line">        <span class="comment">// jedis.auth(&quot;123456&quot;); </span></span><br><span class="line">        System.out.println(<span class="string">&quot;连接成功&quot;</span>);</span><br><span class="line">        <span class="comment">//查看服务是否运行</span></span><br><span class="line">        System.out.println(<span class="string">&quot;服务正在运行: &quot;</span>+jedis.ping());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>redis</category>
      </categories>
      <tags>
        <tag>数据类型</tag>
        <tag>事务</tag>
        <tag>jedis</tag>
      </tags>
  </entry>
</search>
