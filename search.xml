<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>ElasticSearch</title>
    <url>/post/d48132d3/</url>
    <content><![CDATA[<span id="more"></span>]]></content>
      <categories>
        <category>ElasticSearch</category>
      </categories>
      <tags>
        <tag>数据类型</tag>
        <tag>事务</tag>
        <tag>jedis</tag>
      </tags>
  </entry>
  <entry>
    <title>Nginx</title>
    <url>/post/65b69107/</url>
    <content><![CDATA[<span id="more"></span>



<h3 id="一-Nginx的介绍"><a href="#一-Nginx的介绍" class="headerlink" title="一.Nginx的介绍"></a>一.Nginx的介绍</h3><ul>
<li>Nginx是一个开源的，支持高性能、高并发的 Web 服务和反向代理服务器。</li>
<li>Nginx使用异步事件驱动的方法来处理请求，Nginx的模块化事件驱动架构可以在高负载下提供更可预测的性能。</li>
<li>Nginx是一款面向性能设计的HTTP服务器，相较于Apache、lighttpd具有占有内存少，稳定性高等优势。</li>
<li>可大量并行处理，Nginx在官方测试的结果中，能够支持五万个并行连接，而在实际的运作中，可以支持二万至四万个并行连接等等。</li>
</ul>
<h3 id="二-Nginx的功能"><a href="#二-Nginx的功能" class="headerlink" title="二.Nginx的功能"></a>二.Nginx的功能</h3><ol>
<li><p>反向代理</p>
<ul>
<li><p>反向代理的作用：隐藏服务器信息 -&gt; 保证内网的安全，通常将反向代理作为公网访问地址，web服务器是内网，即通过nginx配置外网访问web服务器内网。</p>
</li>
<li><p>配置反向代理</p>
<ul>
<li><p>找到nginx配置文件nginx.conf</p>
<ul>
<li><p>docker拉取的nginx，默认配置文件是nginx.conf中引入包含的default.conf文件<br>也就是说nginx.conf配置文件中有如下一个配置</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">include /etc/nginx/conf.d/*.conf;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>修改配置 -&gt; 实现反向代理</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen       80;</span><br><span class="line">    server_name  www.wyp611.com;<span class="comment"># 服务器地址或绑定域名</span></span><br><span class="line"></span><br><span class="line">    location / &#123; <span class="comment"># 访问80端口后的所有路径都转发到 proxy_pass 配置的ip中</span></span><br><span class="line">        root   /usr/share/nginx/html;</span><br><span class="line">        index  index.html index.htm;</span><br><span class="line">           proxy_pass http://wyp611.top; <span class="comment"># 配置反向代理的ip地址和端口号 【注：url地址需加上https://】</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<p>#注意：每次改完nginx配置，都需要出来docker stop nginx  和  docker start nginx才能使配置生效</p>
<pre><code><figure class="highlight asciidoc"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="bullet">- </span>复杂配置 -&gt; 根据不同的后缀名访问不同的服务器地址</span><br><span class="line"></span><br><span class="line"><span class="code">  </span></span><br></pre></td></tr></table></figure>
</code></pre>
</li>
<li><p>负载均衡</p>
<ul>
<li><p>负载均衡介绍</p>
<ul>
<li>Nginx提供的负载均衡策略有2种：内置策略和扩展策略。</li>
<li>内置策略为轮询，加权轮询，Ip hash。扩展策略，就非常多。</li>
</ul>
</li>
<li><p>负载均衡的几种常用方式</p>
<ul>
<li><p>轮询（默认）：每个请求按时间顺序逐一分配到不同的后端服务器，如果后端服务器down掉，能自动剔除。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">upstream backserver &#123;</span><br><span class="line">    server 192.168.0.14;</span><br><span class="line">    server 192.168.0.15;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<p>location / { </p>
<pre><code>  proxy_pass http://backserver;
</code></pre>
<p>}</p>
  <figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- weight：指定轮询几率，weight和访问比率成正比，用于后端服务器性能不均的情况。</span><br><span class="line"></span><br><span class="line">  ```bash</span><br><span class="line">  upstream backserver &#123;</span><br><span class="line">   <span class="built_in"> server </span>192.168.0.14 <span class="attribute">weight</span>=3;</span><br><span class="line">     <span class="built_in"> server </span>192.168.0.15 <span class="attribute">weight</span>=7;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>ip_hash：上述方式存在一个问题就是说，在负载均衡系统中，假如用户在某台服务器上登录了，那么该用户第二次请求的时候，因为我们是负载均衡系统，每次请求都会重新定位到服务器集群中的某一个，那么<strong>已经登录某一个服务器的用户再重新定位到另一个服务器，其登录信息将会丢失，这样显然是不妥的</strong>。我们可以采用<strong>ip_hash</strong>指令解决这个问题，如果客户已经访问了某个服务器，当用户再次访问时，会将该请求通过<strong>哈希算法，自动定位到该服务器，每个请求按访问ip的hash结果分配，这样每个访客固定访问一个后端服务器，可以解决session的问题</strong>。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">  upstream backserver &#123;</span><br><span class="line">      ip_hash;</span><br><span class="line">    server 192.168.0.14:88;</span><br><span class="line">      server 192.168.0.15:80;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>fair：按后端服务器的响应时间来分配请求，响应时间短的优先分配。</p>
<figure class="highlight abnf"><table><tr><td class="code"><pre><span class="line">upstream backserver &#123;</span><br><span class="line">    server server1<span class="comment">;</span></span><br><span class="line">  server server2<span class="comment">;</span></span><br><span class="line">    fair<span class="comment">;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
<li><p>动静分离</p>
<ul>
<li>动静分离是将网站静态资源（HTML，JavaScript，CSS，img等文件）与后台应用分开部署，提高用户访问静态代码的速度，降低对后台应用访问。</li>
<li><strong>动静分离的一种常用做法：</strong>将静态资源部署在nginx上，后台项目部署到应用服务器上，根据一定规则静态资源的请求调度到nginx服务器，达到动静分离的目标。</li>
<li><a href="https://www.cnblogs.com/itzgr/p/13335271.html">Nginx动静分离 </a></li>
</ul>
</li>
</ol>
<h3 id="三-Nginx配置文件结构"><a href="#三-Nginx配置文件结构" class="headerlink" title="三.Nginx配置文件结构"></a>三.Nginx配置文件结构</h3><ol>
<li><p>nginx文件结构</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">...              <span class="comment">#全局块</span></span><br><span class="line"></span><br><span class="line">events &#123;         <span class="comment">#events块</span></span><br><span class="line">   ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">http      <span class="comment">#http块</span></span><br><span class="line">&#123;</span><br><span class="line">    ...   <span class="comment">#http全局块</span></span><br><span class="line">    server        <span class="comment">#server块</span></span><br><span class="line">    &#123; </span><br><span class="line">        ...       <span class="comment">#server全局块</span></span><br><span class="line">        location [PATTERN]   <span class="comment">#location块</span></span><br><span class="line">        &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">        location [PATTERN] </span><br><span class="line">        &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    server</span><br><span class="line">    &#123;</span><br><span class="line">      ...</span><br><span class="line">    &#125;</span><br><span class="line">    ...     <span class="comment">#http全局块</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>全局块</strong>：配置影响nginx全局的指令。一般有运行nginx服务器的用户组，nginx进程pid存放路径，日志存放路径，配置文件引入，允许生成worker process数等。</li>
<li><strong>events块</strong>：配置影响nginx服务器或与用户的网络连接。有每个进程的最大连接数，选取哪种事件驱动模型处理连接请求，是否允许同时接受多个网路连接，开启多个网络连接序列化等。</li>
<li><strong>http块</strong>：可以嵌套多个server，配置代理，缓存，日志定义等绝大多数功能和第三方模块的配置。如文件引入，mime-type定义，日志自定义，是否使用sendfile传输文件，连接超时时间，单连接请求数等。</li>
<li><strong>server块</strong>：配置虚拟主机的相关参数，一个http中可以有多个server。</li>
<li><strong>location块</strong>：配置请求的路由，以及各种页面的处理情况。</li>
</ul>
</li>
<li><p>nginx的基本配置</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">########### 每个指令必须有分号结束。#################</span></span><br><span class="line"><span class="comment">#user administrator administrators;  #配置用户或者组，默认为nobody nobody。</span></span><br><span class="line"><span class="comment">#worker_processes 2;  #允许生成的进程数，默认为1</span></span><br><span class="line"><span class="comment">#pid /nginx/pid/nginx.pid;   #指定nginx进程运行文件存放地址</span></span><br><span class="line">error_log <span class="built_in">log</span>/error.log debug;  <span class="comment">#制定日志路径，级别。这个设置可以放入全局块，http块，server块，级别以此为：debug|info|notice|warn|error|crit|alert|emerg</span></span><br><span class="line">events &#123;</span><br><span class="line">    accept_mutex on;   <span class="comment">#设置网路连接序列化，防止惊群现象发生，默认为on</span></span><br><span class="line">    multi_accept on;  <span class="comment">#设置一个进程是否同时接受多个网络连接，默认为off</span></span><br><span class="line">    <span class="comment">#use epoll;      #事件驱动模型，select|poll|kqueue|epoll|resig|/dev/poll|eventport</span></span><br><span class="line">    worker_connections  1024;    <span class="comment">#最大连接数，默认为512</span></span><br><span class="line">&#125;</span><br><span class="line">http &#123;</span><br><span class="line">    include       mime.types;   <span class="comment">#文件扩展名与文件类型映射表</span></span><br><span class="line">    default_type  application/octet-stream; <span class="comment">#默认文件类型，默认为text/plain</span></span><br><span class="line">    <span class="comment">#access_log off; #取消服务日志    </span></span><br><span class="line">    log_format myFormat <span class="string">&#x27;$remote_addr–$remote_user [$time_local] $request $status $body_bytes_sent $http_referer $http_user_agent $http_x_forwarded_for&#x27;</span>; <span class="comment">#自定义格式</span></span><br><span class="line">    access_log <span class="built_in">log</span>/access.log myFormat;  <span class="comment">#combined为日志格式的默认值</span></span><br><span class="line">    sendfile on;   <span class="comment">#允许sendfile方式传输文件，默认为off，可以在http块，server块，location块。</span></span><br><span class="line">    sendfile_max_chunk 100k;  <span class="comment">#每个进程每次调用传输数量不能大于设定的值，默认为0，即不设上限。</span></span><br><span class="line">    keepalive_timeout 65;  <span class="comment">#连接超时时间，默认为75s，可以在http，server，location块。</span></span><br><span class="line"></span><br><span class="line">    upstream mysvr &#123;   </span><br><span class="line">      server 127.0.0.1:7878;</span><br><span class="line">      server 192.168.10.121:3333 backup;  <span class="comment">#热备</span></span><br><span class="line">    &#125;</span><br><span class="line">    error_page 404 https://www.baidu.com; <span class="comment">#错误页</span></span><br><span class="line">    server &#123;</span><br><span class="line">        keepalive_requests 120; <span class="comment">#单连接请求上限次数。</span></span><br><span class="line">        listen       4545;   <span class="comment">#监听端口</span></span><br><span class="line">        server_name  127.0.0.1;   <span class="comment">#监听地址       </span></span><br><span class="line">        location  ~*^.+$ &#123;       <span class="comment">#请求的url过滤，正则匹配，~为区分大小写，~*为不区分大小写。</span></span><br><span class="line">           <span class="comment">#root path;  #根目录</span></span><br><span class="line">           <span class="comment">#index vv.txt;  #设置默认页</span></span><br><span class="line">           proxy_pass  http://mysvr;  <span class="comment">#请求转向mysvr 定义的服务器列表</span></span><br><span class="line">           deny 127.0.0.1;  <span class="comment">#拒绝的ip</span></span><br><span class="line">           allow 172.18.5.54; <span class="comment">#允许的ip           </span></span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <categories>
        <category>nginx</category>
      </categories>
      <tags>
        <tag>反向代理</tag>
        <tag>负载均衡</tag>
        <tag>动静分离</tag>
        <tag>配置文件</tag>
      </tags>
  </entry>
  <entry>
    <title>RabbitMQ</title>
    <url>/post/b543ced0/</url>
    <content><![CDATA[<span id="more"></span>]]></content>
      <categories>
        <category>RabbtMQ</category>
      </categories>
      <tags>
        <tag>数据类型</tag>
        <tag>事务</tag>
        <tag>jedis</tag>
      </tags>
  </entry>
  <entry>
    <title>docker初学</title>
    <url>/post/a3ab2041/</url>
    <content><![CDATA[<span id="more"></span>

<h3 id="一-Docker介绍"><a href="#一-Docker介绍" class="headerlink" title="一.Docker介绍"></a>一.Docker介绍</h3><ul>
<li><p>Docker 是一个开源的应用容器引擎，基于Go语言并遵从 Apache2.0 协议开源。</p>
</li>
<li><p>Docker 可以让开发者打包他们的应用以及依赖包到一个轻量级、可移植的容器中，然后发布到任何流行的 Linux 机器上，也可以实现虚拟化。</p>
</li>
<li><p>容器是完全使用沙箱机制，相互之间不会有任何接口（类似 iPhone 的 app）,更重要的是容器性能开销极低。</p>
</li>
</ul>
<h3 id="二-Docker的应用场景"><a href="#二-Docker的应用场景" class="headerlink" title="二.Docker的应用场景"></a>二.Docker的应用场景</h3><ul>
<li><p>Web 应用的自动化打包和发布。</p>
</li>
<li><p>自动化测试和持续集成、发布。</p>
</li>
<li><p>在服务型环境中部署和调整数据库或其他的后台应用。</p>
</li>
<li><p>从头编译或者扩展现有的 OpenShift 或 Cloud Foundry 平台来搭建自己的 PaaS 环境。</p>
</li>
</ul>
<h3 id="三-Docker的优点"><a href="#三-Docker的优点" class="headerlink" title="三.Docker的优点"></a>三.Docker的优点</h3><ul>
<li><p>Docker 是一个用于开发，交付和运行应用程序的开放平台。</p>
</li>
<li><p>Docker 使您能够将应用程序与基础架构分开，从而可以快速交付软件。</p>
</li>
<li><p>借助 Docker，您可以与管理应用程序相同的方式来管理基础架构。</p>
</li>
<li><p>通过利用 Docker 的方法来快速交付，测试和部署代码，您可以大大减少编写代码和在生产环境中运行代码之间的延迟。</p>
</li>
</ul>
<h3 id="四-Docker的架构"><a href="#四-Docker的架构" class="headerlink" title="四.Docker的架构"></a>四.Docker的架构</h3><ul>
<li><strong>镜像（Image）</strong>：Docker 镜像（Image）就像是一个模版，可以通过这个模版来创建容器服务。</li>
<li><strong>容器（Container）</strong>：镜像（Image）和容器（Container）的关系，就像是面向对象程序设计中的类和实例一样，镜像是静态的定义，容器是镜像运行时的实体。容器可以被创建、启动、停止、删除、暂停等。</li>
<li><strong>仓库（Repository）</strong>：仓库可看成一个代码控制中心，用来保存镜像。</li>
<li>Docker 使用客户端-服务器 (C/S) 架构模式，使用远程API来管理和创建Docker容器。</li>
</ul>
<h3 id="五-镜像命令"><a href="#五-镜像命令" class="headerlink" title="五.镜像命令"></a>五.镜像命令</h3><ul>
<li><p>帮助命令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#帮助命令</span></span><br><span class="line">docker version			<span class="comment">#显示docker的版本信息</span></span><br><span class="line">docker info			<span class="comment">#显示docker的系统信息，包括容器和镜像的数量</span></span><br><span class="line">docker 命令 --<span class="built_in">help</span>		<span class="comment">#帮助命令</span></span><br></pre></td></tr></table></figure></li>
<li><p>镜像命令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#镜像命令</span></span><br><span class="line">docker images			<span class="comment">#查看所有的镜像</span></span><br><span class="line">docker images -aq		<span class="comment">#-a:列出所有镜像，-q:只显示镜像的id</span></span><br><span class="line">docker search mysql --filter=STARS=3000	<span class="comment">#搜索镜像，且STARS大于3000</span></span><br><span class="line">docker pull mysql:tag		<span class="comment">#下载镜像，如果不写tag，默认就是latest</span></span><br><span class="line">docker rmi -f 镜像id		<span class="comment">#删除指定的镜像</span></span><br><span class="line">docker rmi -f $(docker images -aq)	<span class="comment">#删除全部镜像</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="六-容器命令"><a href="#六-容器命令" class="headerlink" title="六.容器命令"></a>六.容器命令</h3><ul>
<li><p>容器命令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run [可选参数] image		<span class="comment">#新建容器并启动</span></span><br><span class="line"><span class="comment">#可选参数说明</span></span><br><span class="line">--name=<span class="string">&quot;Name&quot;</span>		<span class="comment">#容器的名字，用来区分同一个镜像创建的容器</span></span><br><span class="line">-d			<span class="comment">#后台方式运行</span></span><br><span class="line">-it			<span class="comment">#使用交互方式运行，进入容器查看内容</span></span><br><span class="line">-p 8080:8080		<span class="comment">#指定容器端口，主机端口:容器端口</span></span><br><span class="line"></span><br><span class="line">docker run -it 镜像名 /bin/bash		<span class="comment">#启动并进入容器</span></span><br><span class="line">docker run -d 镜像名			<span class="comment">#后台启动容器</span></span><br><span class="line"><span class="built_in">exit</span>			<span class="comment">#容器停止并退回主机</span></span><br><span class="line">ctrl+p+q		<span class="comment">#容器不停止退出</span></span><br><span class="line">docker <span class="built_in">exec</span> -it 容器id /bin/bash	<span class="comment">#进入正在运行的容器，会开启新的终端</span></span><br><span class="line">docker attach 容器id		<span class="comment">#进入容器正在执行的终端，不会启动新的进程</span></span><br><span class="line">docker ps			<span class="comment">#列出当前正在运行的容器</span></span><br><span class="line">docker ps -aq		<span class="comment">#a:列出当前正在运行的容器和历史运行过得，q:只显示容器编号</span></span><br><span class="line">docker rm 容器id		<span class="comment">#删除指定容器，不能删除正在运行的，</span></span><br><span class="line">docker rm -f $(docker ps -aq)	<span class="comment">#强制删除所有容器</span></span><br><span class="line">docker start 容器id		<span class="comment">#启动容器</span></span><br><span class="line">docker restart 容器id		<span class="comment">#重启容器</span></span><br><span class="line">docker stop 容器id		<span class="comment">#停止当前正在运行的容器</span></span><br><span class="line">docker <span class="built_in">kill</span> 容器id		<span class="comment">#强制停止当前容器</span></span><br><span class="line">docker inspect 容器id     <span class="comment">#可以查看容器信息</span></span><br></pre></td></tr></table></figure></li>
<li><p>容器中安装vim</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">在使用docker容器时，有时候里边没有安装vim，敲vim命令时提示说：vim: <span class="built_in">command</span> not found，这个时候就需要安装vim，可是当你敲apt-get install vim命令时，提示：</span><br><span class="line"></span><br><span class="line">          Reading package lists... Done</span><br><span class="line">          Building dependency tree       </span><br><span class="line">          Reading state information... Done</span><br><span class="line">          E: Unable to locate package vim</span><br><span class="line">          这时候需要敲：apt-get update，这个命令的作用是：同步 /etc/apt/sources.list 和 /etc/apt/sources.list.d 中列出的源的索引，这样才能获取到最新的软件包。</span><br><span class="line">  </span><br><span class="line">          等更新完毕以后再敲命令：apt-get install vim命令即可。</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="七-其它常用命令"><a href="#七-其它常用命令" class="headerlink" title="七.其它常用命令"></a>七.其它常用命令</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker logs -tf --tail 10 容器id	<span class="comment">#-tf:显示日志，-tail:显示日志条数</span></span><br><span class="line">docker top 容器id		<span class="comment">#查看容器进程信息</span></span><br><span class="line">docker inspect 容器id		<span class="comment">#查看容器元数据</span></span><br><span class="line">docker cp 容器id:容器内路径 目的的主机路径	<span class="comment">#从容器内拷贝文件到主机</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>docker</category>
      </categories>
      <tags>
        <tag>镜像</tag>
        <tag>容器</tag>
      </tags>
  </entry>
  <entry>
    <title>基于springboot的小blog项目</title>
    <url>/post/ed9909aa/</url>
    <content><![CDATA[<span id="more"></span>]]></content>
      <categories>
        <category>item</category>
      </categories>
      <tags>
        <tag>blog</tag>
        <tag>item</tag>
      </tags>
  </entry>
  <entry>
    <title>docker高级</title>
    <url>/post/20caa7eb/</url>
    <content><![CDATA[<span id="more"></span>]]></content>
      <categories>
        <category>docker</category>
      </categories>
      <tags>
        <tag>docker</tag>
        <tag>高级用法</tag>
      </tags>
  </entry>
  <entry>
    <title>docker进阶</title>
    <url>/post/abdfa13a/</url>
    <content><![CDATA[<span id="more"></span>

<h3 id="一-数据管理"><a href="#一-数据管理" class="headerlink" title="一. 数据管理"></a>一. 数据管理</h3><h4 id="1-数据管理的介绍"><a href="#1-数据管理的介绍" class="headerlink" title="1. 数据管理的介绍"></a>1. 数据管理的介绍</h4><ul>
<li>通常情况下，我们是不会在容器中存储数据的。我们会挂载一个主机的文件夹作为数据卷到容器中去，该数据卷可以被许多需要访问的容器访问得到。这样做的好处是保证了数据的持久化，也增强来应用的可移植性（不改变容器配置）。</li>
<li>Docker内部以及容器之间管理数据，在容器中管理数据主要有两种方式：即：数据卷（Data volumes）数据卷容器（Data volume containers）。</li>
</ul>
<h4 id="2-数据卷"><a href="#2-数据卷" class="headerlink" title="2. 数据卷"></a>2. 数据卷</h4><ul>
<li><p>数据卷是一个可以供一个或多个使用的特殊目录，可以提供很多有用的特性</p>
<ul>
<li>数据卷可以在容器之间共享和重用</li>
<li>对数据卷的修改会立马生效</li>
<li>对数据卷的更新，不会影响镜像</li>
<li>卷会一直存在，直到没有容器使用</li>
</ul>
</li>
<li><p>挂载目录</p>
<ul>
<li><p>在使用docker run时，加上-v参数可以创建一个数据卷挂载到目标容器中去，也可以多次使用该参数挂载多个数据卷。下面创建一个容器，挂载一个数据卷。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo docker run --name=<span class="built_in">test</span> -it -v /home/test_volume/:/home/<span class="built_in">test</span> centos</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>挂载文件</p>
<ul>
<li><p>从主机挂载单个文件到容器中，这样就可以记录在容器输入过的命令了。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo docker run --rm -it -v ~/.bash_history:/.bash_history ubuntu /bin/bash</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>匿名挂载</p>
<ul>
<li><p>在- v 只写了容器内的路径，没有写容器外的路径</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@wyplinux01 /] docker run -d -P --name=nginx02 -v /etc/nginx nginx</span><br><span class="line">271c26643061b31d3385100dd77aa9fb2bf5f8fdf5d7591304cf946ae5423f8c</span><br><span class="line">root@wyplinux01 /] docker volume ls</span><br><span class="line">DRIVER    VOLUME NAME</span><br><span class="line"><span class="built_in">local</span>     271c26643061b31d3385100dd77aa9fb2bf5f8fdf5d7591304cf946ae5423f8c</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>具名挂载</p>
<ul>
<li><p>所有的 docker 容器内的卷，没有指定目录的情况下都是在 <strong>/var/lib/docker/volumes/xxx/_data</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@wyplinux01 /] docker run -d -P --name=nginx02 -v juming-nginx:/etc/nginx nignx</span><br><span class="line">271c26643061b31d3385100dd77aa9fb2bf5f8fdf5d7591304cf946ae5423f8c</span><br><span class="line">root@wyplinux01 /] docker volume ls</span><br><span class="line">DRIVER    VOLUME NAME</span><br><span class="line"><span class="built_in">local</span>     juming-nginx</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h4 id="3-数据卷容器"><a href="#3-数据卷容器" class="headerlink" title="3. 数据卷容器"></a>3. 数据卷容器</h4><ul>
<li><p>数据卷容器，其实就是一个正常的容器，专门用来提供数据卷供其它容器挂载的。 </p>
</li>
<li><p>我们首先先创建一个数据卷容器使用 <strong>–volumes-from</strong> 参数所挂载数据卷的容器自己并不需要保持在运行状态。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run -d -v /nginx --name=nginx01 nginx</span><br></pre></td></tr></table></figure>

<p>发现创建好的数据卷容器是出于停止运行的状态，因为使用 –volumes-from 参数所挂载数据卷的容器自己并不需要保持在运行状态。然后我们再创建容器挂载这个数据卷。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run -d --volumes-from nginx01 --name=nginx02 nginx</span><br><span class="line">docker run -d --volumes-from nginx01 --name=nginx03 nginx</span><br></pre></td></tr></table></figure>

<p>还可以使用多个 –volumes-from 参数来从多个容器挂载多个数据卷。 也可以从其他已经挂载了数据卷的容器来挂载数据卷。</p>
<p>如果删除了挂载的容器（包括 nginx01、nginx02 和 nginx03），数据卷并不会被自动删除。如果要删除一个数据卷，必须在删除最后一个还挂载着它的容器时使用 docker rm -v 命令来指定同时删除关联的容器， 这可以让用户在容器之间升级和移动数据卷。</p>
</li>
</ul>
<h3 id="二-Dockerfile"><a href="#二-Dockerfile" class="headerlink" title="二. Dockerfile"></a>二. Dockerfile</h3><h4 id="1-基本结构"><a href="#1-基本结构" class="headerlink" title="1. 基本结构"></a>1. 基本结构</h4><ul>
<li><p>Dockerfile 由一行行命令语句组成，并且支持以 # 开头的注释行，一般的，Dockerfile 分为四部分：基础镜像信息、维护者信息、镜像操作指令和容器启动时执行指令。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#基础镜像信息</span></span><br><span class="line">FROM ubuntu</span><br><span class="line"></span><br><span class="line"><span class="comment"># 维护者信息</span></span><br><span class="line">MAINTAINER docker_user [email protected]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 镜像操作指令</span></span><br><span class="line">RUN <span class="built_in">echo</span> <span class="string">&quot;deb http://archive.ubuntu.com/ubuntu/ raring main universe&quot;</span> &gt;&gt; /etc/apt/sources.list</span><br><span class="line">RUN apt-get update &amp;&amp; apt-get install -y nginx</span><br><span class="line">RUN <span class="built_in">echo</span> <span class="string">&quot;\ndaemon off;&quot;</span> &gt;&gt; /etc/nginx/nginx.conf</span><br><span class="line"></span><br><span class="line"><span class="comment"># 容器启动时执行指令</span></span><br><span class="line">CMD /usr/sbin/nginx</span><br></pre></td></tr></table></figure>

<p>其中，一开始必须指明所基于的镜像名称，接下来推荐说明维护者信息。</p>
<p>后面则是镜像操作指令，例如 RUN 指令，RUN 指令将对镜像执行跟随的命令。每运行一条 RUN 指令，镜像添加新的一层，并提交。</p>
<p>最后是 CMD 指令，来指定运行容器时的操作命令。</p>
</li>
</ul>
<h4 id="2-命令参数"><a href="#2-命令参数" class="headerlink" title="2. 命令参数"></a>2. 命令参数</h4><ul>
<li><p>FROM</p>
<figure class="highlight sqf"><table><tr><td class="code"><pre><span class="line">格式为 <span class="keyword">FROM</span> &lt;<span class="built_in">image</span>&gt;或<span class="keyword">FROM</span> &lt;<span class="built_in">image</span>&gt;:&lt;tag&gt;</span><br></pre></td></tr></table></figure>

<p>第一条指令必须为<code>FROM</code> 指令。并且，如果在同一个Dockerfile中创建多个镜像时，可以使用多个<code>FROM</code> 指令（每个镜像一次）。</p>
</li>
<li><p>MAINTAINER</p>
<figure class="highlight applescript"><table><tr><td class="code"><pre><span class="line">格式为 MAINTAINER &lt;<span class="built_in">name</span>&gt;，指定维护者信息。</span><br></pre></td></tr></table></figure></li>
<li><p>RUN</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">格式为 <span class="builtin-name">RUN</span> &lt;command&gt; 或 <span class="builtin-name">RUN</span> [<span class="string">&quot;executable&quot;</span>, <span class="string">&quot;param1&quot;</span>, <span class="string">&quot;param2&quot;</span>]</span><br></pre></td></tr></table></figure>

<p><code>前者将在 shell 终端中运行命令</code> ，即 /bin/sh -c；<code>后者则使用 exec 执行</code> 。指定使用其它终端可以通过第二种方式实现，例如 <code>RUN [&quot;/bin/bash&quot;, &quot;-c&quot;, &quot;echo hello&quot;]。</code></p>
<p>每条 <code>RUN</code> 指令将在当前镜像基础上执行指定命令，并提交为新的镜像。当命令较长时可以使用 \ 来换行。</p>
</li>
<li><p>CMD</p>
<p>支持三种格式</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CMD</span><span class="bash"> [<span class="string">&quot;executable&quot;</span>,<span class="string">&quot;param1&quot;</span>,<span class="string">&quot;param2&quot;</span>] 使用 <span class="built_in">exec</span> 执行，推荐方式；</span></span><br><span class="line"><span class="keyword">CMD</span><span class="bash"> <span class="built_in">command</span> param1 param2 在 /bin/sh 中执行，提供给需要交互的应用；</span></span><br><span class="line"><span class="keyword">CMD</span><span class="bash"> [<span class="string">&quot;param1&quot;</span>,<span class="string">&quot;param2&quot;</span>] 提供给 ENTRYPOINT 的默认参数；</span></span><br></pre></td></tr></table></figure>

<p>指定启动容器时执行的命令，每个 Dockerfile 只能有一条<code>CMD</code> 命令，如果指定了多条命令，只有最后一条会被执行。</p>
<p>如果用户启动容器时候指定了运行的命令，则会覆盖掉 <code>CMD</code> 指定的命令。</p>
</li>
<li><p>EXPOSE</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">EXPOSE <span class="tag">&lt;<span class="name">port</span>&gt;</span> [<span class="tag">&lt;<span class="name">port</span>&gt;</span>...]。</span><br></pre></td></tr></table></figure>

<p>告诉 Docker 服务端容器暴露的端口号，供互联系统使用。在启动容器时需要通过 <code>-P</code> ，Docker 主机会自动分配一个端口转发到指定的端口。</p>
</li>
<li><p>ENV</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">ENV <span class="tag">&lt;<span class="name">key</span>&gt;</span> <span class="tag">&lt;<span class="name">value</span>&gt;</span>。</span><br></pre></td></tr></table></figure>

<p>指定一个环境变量，会被后续 <code>RUN</code> 指令使用，并在容器运行时保持。</p>
<p>例如</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">ENV PG_MAJOR <span class="number">9.3</span></span><br><span class="line">ENV PG_VERSION <span class="number">9.3</span><span class="number">.4</span></span><br><span class="line">RUN curl -SL http://example.com/postgres-$PG_VERSION.tar.xz | tar -xJC /usr/src/postgress &amp;&amp; …</span><br><span class="line">ENV <span class="type">PATH</span> /usr/<span class="keyword">local</span>/postgres-$PG_MAJOR/bin:$<span class="type">PATH</span></span><br></pre></td></tr></table></figure></li>
<li><p>ADD</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">ADD <span class="tag">&lt;<span class="name">src</span>&gt;</span> <span class="tag">&lt;<span class="name">dest</span>&gt;</span>。</span><br></pre></td></tr></table></figure>

<p>该命令将复制指定的内容到容器中。 其中可以是Dockerfile所在目录的一个相对路径；也可以是一个 URL；还可以是一个 tar 文件（自动解压为目录）。</p>
</li>
<li><p>COPY</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">COPY <span class="tag">&lt;<span class="name">src</span>&gt;</span> <span class="tag">&lt;<span class="name">dest</span>&gt;</span>。</span><br></pre></td></tr></table></figure>

<p>复制本地主机的内容（为 Dockerfile 所在目录的相对路径）到容器中。</p>
<p>当使用本地目录为源目录时，推荐使用 COPY。</p>
</li>
<li><p>ENTRYPOINT</p>
<p>两种格式：</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ENTRYPOINT</span><span class="bash"> [<span class="string">&quot;executable&quot;</span>, <span class="string">&quot;param1&quot;</span>, <span class="string">&quot;param2&quot;</span>]</span></span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="bash"> <span class="built_in">command</span> param1 param2（shell中执行）。</span></span><br></pre></td></tr></table></figure>

<p>配置容器启动后执行的命令，并且不可被 <code>docker run</code> 提供的参数覆盖。</p>
<p>每个 Dockerfile 中只能有一个 <code>ENTRYPOINT</code> ，当指定多个时，只有最后一个起效。</p>
</li>
<li><p>VOLUME</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">VOLUME <span class="selector-attr">[<span class="string">&quot;/data&quot;</span>]</span>。</span><br></pre></td></tr></table></figure>

<p>创建一个可以从本地主机或其他容器挂载的挂载点，一般用来存放数据库和需要保持的数据等。    </p>
</li>
<li><p>USER</p>
<figure class="highlight crmsh"><table><tr><td class="code"><pre><span class="line"><span class="keyword">USER</span> <span class="title">daemon</span>。</span><br></pre></td></tr></table></figure>

<p>指定运行容器时的用户名或 UID，后续的 RUN 也会使用指定用户。</p>
<p>当服务不需要管理员权限时，可以通过该命令指定运行用户。并且可以在之前创建所需要的用户，例如：<code>RUN groupadd -r postgres &amp;&amp; useradd -r -g postgres postgres</code> 。<code>要临时获取管理员权限可以使用 gosu，而不推荐 sudo</code> 。</p>
</li>
<li><p>WORKDIR</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">WORKDIR <span class="regexp">/path/</span>to/workdir。</span><br></pre></td></tr></table></figure>

<p>为后续的 <code>RUN、CMD、ENTRYPOINT</code> 指令配置工作目录。</p>
<p>可以使用多个<code>WORKDIR</code> 指令，后续命令如果参数是相对路径，则会基于之前命令指定的路径。例如</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">WORKDIR</span><span class="bash"> /a</span></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="bash"> b</span></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="bash"> c</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> <span class="built_in">pwd</span></span></span><br></pre></td></tr></table></figure>

<p>则最终路径为 <code>/a/b/c</code> 。</p>
</li>
<li><p>ONBUILD</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">ONBUILD <span class="selector-attr">[INSTRUCTION]</span>。</span><br></pre></td></tr></table></figure>

<p>配置当所创建的镜像作为其它新创建镜像的基础镜像时，所执行的操作指令。</p>
<p>例如，Dockerfile 使用如下的内容创建了镜像 image-A。</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">[...]</span><br><span class="line">ONBUILD ADD . <span class="regexp">/app/</span>src</span><br><span class="line">ONBUILD RUN <span class="regexp">/usr/</span>local<span class="regexp">/bin/</span>python-build --dir <span class="regexp">/app/</span>src</span><br><span class="line">[...]</span><br></pre></td></tr></table></figure>

<p>如果基于 image-A 创建新的镜像时，新的Dockerfile中使用 FROM image-A指定基础镜像时，会自动执行 ONBUILD 指令内容，等价于在后面添加了两条指令。</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">FROM image-A</span><br><span class="line"><span class="comment">#Automatically run the following</span></span><br><span class="line">ADD . <span class="regexp">/app/</span>src</span><br><span class="line">RUN <span class="regexp">/usr/</span>local<span class="regexp">/bin/</span>python-build --dir <span class="regexp">/app/</span>src</span><br></pre></td></tr></table></figure>

<p>使用 ONBUILD 指令的镜像，推荐在标签中注明，例如 <code>ruby:1.9-onbuild</code> 。</p>
</li>
</ul>
<h3 id="三-docker网络"><a href="#三-docker网络" class="headerlink" title="三. docker网络"></a>三. docker网络</h3><h4 id="1-外部访问容器"><a href="#1-外部访问容器" class="headerlink" title="1. 外部访问容器"></a>1. 外部访问容器</h4><ul>
<li><p>容器中可以运行一些网络应用，要让外部也可以访问这些应用，可以通过 <code>-P</code> 或 <code>-p</code> 参数来指定端口映射。</p>
<p>当使用 <code>-P</code> 标记时，Docker 会随机映射一个端口到内部容器开放的网络端口。</p>
<p><code>-p</code> 则可以指定要映射的端口，并且，在一个指定端口上只可以绑定一个容器。支持的格式有 <code>ip:hostPort:containerPort | ip::containerPort | hostPort:containerPort</code>。</p>
</li>
<li><p><strong>映射所有接口地址</strong></p>
<p>使用 <code>hostPort:containerPort</code> 格式，本地的 80 端口映射到容器的 80 端口，可以执行</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">$ docker <span class="builtin-name">run</span> -d -p 80:80 nginx:alpine</span><br></pre></td></tr></table></figure></li>
<li><p><strong>映射到指定地址的指定端口</strong></p>
<p>可以使用 <code>ip:hostPort:containerPort</code> 格式指定映射使用一个特定地址，比如 localhost 地址 127.0.0.1</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">$ docker <span class="builtin-name">run</span> -d -p 127.0.0.1:80:80 nginx:alpine</span><br></pre></td></tr></table></figure></li>
<li><p><strong>映射到指定地址的任意端口</strong></p>
<p>使用 <code>ip::containerPort</code> 绑定 localhost 的任意端口到容器的 80 端口，本地主机会自动分配一个端口。</p>
<figure class="highlight dns"><table><tr><td class="code"><pre><span class="line">$ docker run -d -p <span class="number">127.0.0.1</span><span class="number">::80</span> nginx:alpine</span><br></pre></td></tr></table></figure>

<p>还可以使用 <code>udp</code> 标记来指定 <code>udp</code> 端口</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">$ docker <span class="builtin-name">run</span> -d -p 127.0.0.1:80:80/udp nginx:alpine</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="2-容器互联"><a href="#2-容器互联" class="headerlink" title="2. 容器互联"></a>2. 容器互联</h4><ul>
<li><p>在以前使用<code>docker</code>，习惯使用 <code>--link</code> 参数来使容器互联，而现在随着 Docker 网络的完善，强烈建议大家将容器加入自定义的 Docker 网络来连接多个容器，而不是使用 <code>--link</code> 参数。</p>
</li>
<li><p><strong>新建网络</strong></p>
<p>下面先创建一个新的 Docker 网络。</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">$ docker<span class="built_in"> network </span>create -d<span class="built_in"> bridge </span>my-net</span><br></pre></td></tr></table></figure>

<p><code>-d</code> 参数指定 Docker 网络类型，有 <code>bridge</code> 、<code>overlay</code>。</p>
</li>
<li><p><strong>连接容器</strong></p>
<p>运行一个容器并连接到新建的 <code>my-net</code> 网络</p>
<figure class="highlight stata"><table><tr><td class="code"><pre><span class="line">$ docker <span class="keyword">run</span> -it --<span class="keyword">rm</span> --name busybox1 --network my-<span class="keyword">net</span> busybox <span class="keyword">sh</span></span><br></pre></td></tr></table></figure>

<p>打开新的终端，再运行一个容器并加入到 <code>my-net</code> 网络</p>
<figure class="highlight stata"><table><tr><td class="code"><pre><span class="line">$ docker <span class="keyword">run</span> -it --<span class="keyword">rm</span> --name busybox2 --network my-<span class="keyword">net</span> busybox <span class="keyword">sh</span></span><br></pre></td></tr></table></figure>

<p>再打开一个新的终端查看容器信息</p>
<figure class="highlight mipsasm"><table><tr><td class="code"><pre><span class="line">$ docker container ls</span><br><span class="line">CONTAINER ID      IMAGE            COMMAND         CREATED          STATUS           PORTS       NAMES <span class="keyword">b47060aca56b </span>     <span class="keyword">busybox </span>          <span class="string">&quot;sh&quot;</span>        <span class="number">11</span> minutes ago   Up <span class="number">11</span> minutes                  <span class="keyword">busybox2 </span><span class="number">8720575823</span>ec      <span class="keyword">busybox </span>          <span class="string">&quot;sh&quot;</span>        <span class="number">16</span> minutes ago   Up <span class="number">16</span> minutes                  <span class="keyword">busybox1 </span></span><br></pre></td></tr></table></figure>

<p>下面通过 <code>ping</code> 来证明 <code>busybox1</code> 容器和 <code>busybox2</code> 容器建立了互联关系。</p>
<p>在 <code>busybox1</code> 容器输入以下命令</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">/ #<span class="built_in"> ping </span>busybox2</span><br><span class="line">PING busybox2 (172.19.0.3): 56 data bytes</span><br><span class="line">64 bytes <span class="keyword">from</span> 172.19.0.3: <span class="attribute">seq</span>=0 <span class="attribute">ttl</span>=64 <span class="attribute">time</span>=0.072 ms</span><br><span class="line">64 bytes <span class="keyword">from</span> 172.19.0.3: <span class="attribute">seq</span>=1 <span class="attribute">ttl</span>=64 <span class="attribute">time</span>=0.118 ms</span><br></pre></td></tr></table></figure>

<p>用 ping 来测试连接 <code>busybox2</code> 容器，它会解析成 <code>172.19.0.3</code>。</p>
<p>同理在 <code>busybox2</code> 容器执行 <code>ping busybox1</code>，也会成功连接到。</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">/ #<span class="built_in"> ping </span>busybox1</span><br><span class="line">PING busybox1 (172.19.0.2): 56 data bytes</span><br><span class="line">64 bytes <span class="keyword">from</span> 172.19.0.2: <span class="attribute">seq</span>=0 <span class="attribute">ttl</span>=64 <span class="attribute">time</span>=0.064 ms</span><br><span class="line">64 bytes <span class="keyword">from</span> 172.19.0.2: <span class="attribute">seq</span>=1 <span class="attribute">ttl</span>=64 <span class="attribute">time</span>=0.143 ms</span><br></pre></td></tr></table></figure>

<p>这样，<code>busybox1</code> 容器和 <code>busybox2</code> 容器建立了互联关系。</p>
</li>
</ul>
<h4 id="3-docker0"><a href="#3-docker0" class="headerlink" title="3. docker0"></a>3. docker0</h4><ul>
<li><p>docker 服务默认会创建一个 <code>docker0</code> 网桥（其上有一个 <code>docker0</code> 内部接口），它在内核层连通了其他的物理或虚拟网卡，这就将所有容器和本地主机都放到同一个物理网络。</p>
<p>由于目前 Docker 网桥是 Linux 网桥，用户可以使用 <code>brctl show</code> 来查看网桥和端口连接信息。</p>
<figure class="highlight mipsasm"><table><tr><td class="code"><pre><span class="line">$ sudo <span class="keyword">brctl </span><span class="keyword">show</span></span><br><span class="line"><span class="keyword">bridge </span>name     <span class="keyword">bridge </span>id               STP enabled     interfaces</span><br><span class="line">docker0         <span class="number">8000</span>.<span class="number">3</span>a1d<span class="symbol">7362b</span>4ee       no              veth<span class="symbol">65f</span>9</span><br><span class="line">                                             			vethdda6</span><br></pre></td></tr></table></figure>

<p>每次创建一个新容器的时候，Docker 从可用的地址段中选择一个空闲的 IP 地址分配给容器的 eth0 （容器内部的网卡，和docker0上的是一对）端口。使用本地主机上 <code>docker0</code> 接口的 IP 作为所有容器的默认网关。</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">$ sudo docker <span class="builtin-name">run</span> -i -t --rm base /bin/bash</span><br><span class="line">$<span class="built_in"> ip </span>addr show eth0</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>docker</category>
      </categories>
      <tags>
        <tag>目录挂载</tag>
        <tag>dockerfile</tag>
        <tag>docker网络</tag>
      </tags>
  </entry>
  <entry>
    <title>git</title>
    <url>/post/518e617c/</url>
    <content><![CDATA[<span id="more"></span>

<h3 id="一-Git介绍"><a href="#一-Git介绍" class="headerlink" title="一.Git介绍"></a>一.Git介绍</h3><ul>
<li>Git 是一个开源的分布式版本控制系统，用于敏捷高效地处理任何或小或大的项目。</li>
<li>Git 是 Linus Torvalds 为了帮助管理 Linux 内核开发而开发的一个开放源码的版本控制软件。</li>
<li>Git 与常用的版本控制工具 CVS, Subversion 等不同，它采用了分布式版本库的方式。</li>
</ul>
<h3 id="二-Git工作区、暂存区和版本库"><a href="#二-Git工作区、暂存区和版本库" class="headerlink" title="二.Git工作区、暂存区和版本库"></a>二.Git工作区、暂存区和版本库</h3><ul>
<li><strong>工作区：</strong>就是你在电脑里能看到的目录。</li>
<li><strong>暂存区：</strong>英文叫 stage 或 index。一般存放在 <strong>.git</strong> 目录下的 index 文件（.git/index）中，所以我们把暂存区有时也叫作索引（index）。</li>
<li><strong>版本库：</strong>工作区有一个隐藏目录 <strong>.git</strong>，这个不算工作区，而是 Git 的版本库。</li>
<li>[工作区、版本库中的暂存区和版本库之间的关系](<a href="https://www.runoob.com/git/git-workspace-index-repo.html">Git 工作区、暂存区和版本库 | 菜鸟教程 (runoob.com)</a>)</li>
</ul>
<h3 id="三-Git的工作流程"><a href="#三-Git的工作流程" class="headerlink" title="三.Git的工作流程"></a>三.Git的工作流程</h3><ol>
<li><p>从远程仓库中克隆代码到本地仓库。</p>
</li>
<li><p>从本地仓库中checkout代码，然后进行代码修改。</p>
</li>
<li><p>在提交前先将代码提交到暂存区。</p>
</li>
<li><p>提交到本地仓库，本地仓库中保存需改的各个历史版本。</p>
<p><img data-src="https://wyp-blog.oss-cn-beijing.aliyuncs.com/git/Snipaste_2021-05-04_21-39-27.png" alt="工作流程"></p>
</li>
</ol>
<h3 id="四-Git的使用"><a href="#四-Git的使用" class="headerlink" title="四.Git的使用"></a>四.Git的使用</h3><h4 id="1-Git的环境配置"><a href="#1-Git的环境配置" class="headerlink" title="1.Git的环境配置"></a>1.Git的环境配置</h4><ul>
<li><p>当安装Git后首先要做的事情是设置用户名称和email地址。</p>
</li>
<li><p>设置用户信息</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git config --global user.name <span class="string">&quot;用户名称&quot;</span></span><br><span class="line">git config --global user.email <span class="string">&quot;email&quot;</span></span><br></pre></td></tr></table></figure></li>
<li><p>查看用户信息</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git config --list</span><br><span class="line">git config user.name</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="2-获取Git仓库"><a href="#2-获取Git仓库" class="headerlink" title="2.获取Git仓库"></a>2.获取Git仓库</h4><p>​    获取Git仓库通常有两种方式：</p>
<ul>
<li>在本地初始化一个Git仓库<ol>
<li>在电脑的任意位置创建一个空目录作为我们的本地Git仓库。</li>
<li>进入这个目录，点击右键打开<strong>Git bash</strong>窗口。</li>
<li>执行命令<strong>git init</strong>，如果在当前目录中看到**.git** 文件夹（此文件夹为隐藏文件夹）)则说明Git仓库创建成功。</li>
</ol>
</li>
<li>从远程仓库克隆<ol>
<li>可以通过Git提供的命令从远程仓库进行克隆，将远程仓库克隆到本地。</li>
<li>命令形式：<strong>git clone 远程Git仓库地址</strong></li>
</ol>
</li>
</ul>
<h4 id="3-本地仓库操作"><a href="#3-本地仓库操作" class="headerlink" title="3.本地仓库操作"></a>3.本地仓库操作</h4><ol>
<li><p>Git工作目录下的<strong>文件</strong>存在两种状态：</p>
<ul>
<li><strong>untracked</strong>未跟踪（未被纳入版本控制）</li>
<li><strong>tracked</strong>已跟踪（被纳入版本控制）<ul>
<li><strong>unmodified</strong>未修改状态</li>
<li><strong>modified</strong>已修改状态</li>
<li><strong>staged</strong>已暂存状态</li>
</ul>
</li>
</ul>
</li>
<li><p>Git的本地仓库基本命令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git status				<span class="comment">#查看文件状态</span></span><br><span class="line">git add 文件名			<span class="comment">#将未跟踪的文件加入暂存区</span></span><br><span class="line">git reset 文件名			<span class="comment">#将暂存区的文件取消暂存</span></span><br><span class="line">git commit -m <span class="string">&quot;日志&quot;</span> 文件名		<span class="comment">#将暂存区的文件修改提交到本地仓库</span></span><br><span class="line">git rm 文件名			<span class="comment">#删除文件</span></span><br><span class="line">git <span class="built_in">log</span>				<span class="comment">#查看日志</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="4-远程仓库的操作"><a href="#4-远程仓库的操作" class="headerlink" title="4.远程仓库的操作"></a>4.远程仓库的操作</h4><ul>
<li>查看远程仓库</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git remote			<span class="comment">#git克隆的仓库服务器的默认名称为origin</span></span><br><span class="line">git remote -v</span><br><span class="line">git remote show origin</span><br></pre></td></tr></table></figure>

<ul>
<li>添加远程仓库</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git remote add &lt;shortname&gt; &lt;url&gt;			<span class="comment">#添加一个新的远程Git仓库，同时指定一个可以引用的简写</span></span><br></pre></td></tr></table></figure>

<ul>
<li>从远程仓库克隆</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> &lt;url&gt;			<span class="comment">#把该Git仓库服务器上的几乎所有数据（包括日志信息、历史记录等）都克隆，而不仅仅是复制工作所需要的文件</span></span><br></pre></td></tr></table></figure>

<ul>
<li>移除无效的远程仓库</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git remote rm &lt;shortname&gt;			<span class="comment">#此命令只是从本地移除远程仓库的记录，并不会真正影响到远程仓库</span></span><br></pre></td></tr></table></figure>

<ul>
<li>从远程仓库中抓取与拉取</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git fetch [remote-name] [branch-name]		<span class="comment">#从远程仓库获取最新版本到本地仓库，不会自动merge</span></span><br><span class="line">git merge [remote-name] [branch-name]</span><br><span class="line">git pull [remote-name] [branch-name]		<span class="comment">#从远程仓库获取最新版本到本地仓库，会自动merge</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#注意：如果当前本地仓库不是从远程仓库克隆，而是本地创建的仓库，并且仓库中存在文件，此时再从远程仓库拉取文件的时候会报错（fatal：refusing to merge unrelated histories），解决此问题可以在 git pull 命令后加入参数 --rebase</span></span><br></pre></td></tr></table></figure>

<ul>
<li>推送到远程仓库</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git push [remote-name] [branch-name]</span><br></pre></td></tr></table></figure>



<h3 id="五-分支"><a href="#五-分支" class="headerlink" title="五.分支"></a>五.分支</h3><ul>
<li>查看分支</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git branch				<span class="comment">#列出所有本地分支</span></span><br><span class="line">git branch -r			<span class="comment">#列出所有远程分支</span></span><br><span class="line">git brach -a			<span class="comment">#列出所有本地分支和远程分支</span></span><br></pre></td></tr></table></figure>

<ul>
<li>创建分支</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git branch (branchname)</span><br><span class="line"><span class="comment">#当你执行 git init 的时候，默认情况下 Git 就会为你创建 master 分支。如果我们要手动创建一个分支。执行 git branch (branchname) 即可</span></span><br></pre></td></tr></table></figure>

<ul>
<li>切换分支</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git checkout (branchname)</span><br><span class="line"><span class="comment">#当你切换分支的时候，Git 会用该分支的最后提交的快照替换你的工作目录的内容， 所以多个分支不需要多个目录。</span></span><br></pre></td></tr></table></figure>

<ul>
<li>推送至远程仓库分支</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git push (remote-name) (branch-name)</span><br></pre></td></tr></table></figure>

<ul>
<li>合并分支</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git merge</span><br></pre></td></tr></table></figure>

<ul>
<li>删除分支</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git branch -d (branchname)</span><br></pre></td></tr></table></figure>



<p><img data-src="C:\Users\W-Y-P\AppData\Roaming\Typora\typora-user-images\image-20210505215937507.png" alt="image-20210505215937507"></p>
<h3 id="六-标签"><a href="#六-标签" class="headerlink" title="六.标签"></a>六.标签</h3><ul>
<li>列出已有的标签</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git tag			<span class="comment">#列出已有标签</span></span><br><span class="line">git show (tagname)			<span class="comment">#查看tag信息</span></span><br></pre></td></tr></table></figure>

<ul>
<li>创建新标签</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git tag -a (tagname)			<span class="comment">#-a 选项意为&quot;创建一个带注解的标签&quot;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>将标签推送至远程仓库</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git push (remote-name) (tag-name)</span><br></pre></td></tr></table></figure>

<ul>
<li>检出标签</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git checkout -b (branch-name) (tag-name)		<span class="comment">#新建一个分支，指向指定标签</span></span><br></pre></td></tr></table></figure>

<ul>
<li>删除标签</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git tag -d (tagname)</span><br><span class="line">git push (remote-name) :refs/tags/(tag-name)</span><br></pre></td></tr></table></figure>









]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
        <tag>命令</tag>
      </tags>
  </entry>
  <entry>
    <title>linux命令总结</title>
    <url>/post/7f49275c/</url>
    <content><![CDATA[<span id="more"></span>



<h4 id="一-帮助和开机等"><a href="#一-帮助和开机等" class="headerlink" title="一.帮助和开机等"></a>一.帮助和开机等</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#帮助命令</span></span><br><span class="line">man 命令或配置文件		<span class="comment">#获取帮助信息</span></span><br><span class="line"><span class="built_in">help</span> 命令			<span class="comment">#获得shell内置命令的帮助信息</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#开机&amp;重启命令</span></span><br><span class="line">shutdown -h now			<span class="comment">#立刻进行关机</span></span><br><span class="line">halt				<span class="comment">#立刻进行关机</span></span><br><span class="line">shutdown -h 1			<span class="comment">#1分钟后关机</span></span><br><span class="line">shutdown -r now			<span class="comment">#现在重启计算机</span></span><br><span class="line">reboot				<span class="comment">#现在重启计算机</span></span><br><span class="line">sync				<span class="comment">#把内存的数据同步到磁盘</span></span><br></pre></td></tr></table></figure>



<h4 id="二-vim"><a href="#二-vim" class="headerlink" title="二.vim"></a>二.vim</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#vim命令(三种模式:一般模式/正常，编辑模式，命令模式)</span></span><br><span class="line">vi				<span class="comment">#文本编辑器</span></span><br><span class="line">vim				<span class="comment">#具有程序编辑的能力，可以看做是vi的增强版本，且在命令行下， :wq(保存退出)  :q(退出)  :q!(强制退出，不保存)</span></span><br><span class="line">yy				<span class="comment">#拷贝当前行	</span></span><br><span class="line">5yy				<span class="comment">#拷贝当前行向下的5行</span></span><br><span class="line">dd				<span class="comment">#删除当前行</span></span><br><span class="line">5dd				<span class="comment">#删除当前行向下的5行</span></span><br><span class="line"><span class="built_in">set</span> nu				<span class="comment">#设置文件的行号</span></span><br><span class="line">/关键字				<span class="comment">#命令行模式下，回车查找，输入n就是查找下一个</span></span><br><span class="line">G/gg				<span class="comment">#在一般模式下，使用快捷键到该文档的最末行/最首行</span></span><br><span class="line">u				<span class="comment">#在一般模式下，撤销这个动作</span></span><br><span class="line">30				<span class="comment">#在一般模式下，输入30，再输入shift+g是移动到30行</span></span><br></pre></td></tr></table></figure>



<h4 id="三-用户-amp-组"><a href="#三-用户-amp-组" class="headerlink" title="三.用户&amp;组"></a>三.用户&amp;组</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#用户&amp;组命令(/etc/passwd:用户的配置文件，/etc/shadow:口令的配置文件，/etc/group:组的配置文件，记录Linux包含的组的信息)</span></span><br><span class="line">groupadd 组名			<span class="comment">#新增组</span></span><br><span class="line">groupdel 组名			<span class="comment">#删除组</span></span><br><span class="line">useradd 用户名			<span class="comment">#添加一个用户(当用户创建成功后，会自动创建和用户同名的家目录)</span></span><br><span class="line">useradd -d 指定目录 用户名	<span class="comment">#给创建的用户指定家目录</span></span><br><span class="line">useradd -g 组名 用户名		<span class="comment">#创建用户时指定组</span></span><br><span class="line">usermod -g 组名 用户名		<span class="comment">#修改用户的组</span></span><br><span class="line">passwd 用户名			<span class="comment">#给用户指定密码</span></span><br><span class="line">userdel 用户名			<span class="comment">#删除用户，但保留家目录</span></span><br><span class="line">userdel -r 用户名		<span class="comment">#删除用户以及家目录</span></span><br><span class="line">chown 用户名 文件名		<span class="comment">#修改文件所有者</span></span><br><span class="line">chgrp 组名 文件名			<span class="comment">#修改文件所在组</span></span><br><span class="line">chmod u=rwx,g=rx,o=x 文件或目录	<span class="comment">#将文件或目录的权限修改成rwx-xr-x</span></span><br><span class="line">chmod 751 文件或目录		<span class="comment">#将文件或目录的权限修改成rwx-xr-x</span></span><br><span class="line">su 用户名			<span class="comment">#切换用户</span></span><br><span class="line">whoami				<span class="comment">#查看当前用户</span></span><br></pre></td></tr></table></figure>



<h4 id="四-文件目录"><a href="#四-文件目录" class="headerlink" title="四.文件目录"></a>四.文件目录</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#文件目录类命令</span></span><br><span class="line"><span class="built_in">pwd</span>				<span class="comment">#显示当前工作目录的绝对路径</span></span><br><span class="line">ls -la 				<span class="comment">#-a显示当前目录所有的文件和目录，包括隐藏的；-l以列表的方式显示信息</span></span><br><span class="line"><span class="built_in">cd</span> ~/..				<span class="comment">#~回到自己的家目录；回到当前目录的上一级目录</span></span><br><span class="line">mkdir [-p] 目录	   		<span class="comment">#创建目录；-p创建多级目录</span></span><br><span class="line">rmdir [-p] 空目录		<span class="comment">#删除空目录；-p顺序删除多级目录</span></span><br><span class="line">touch 文件名称			<span class="comment">#创建一个文件</span></span><br><span class="line">cp [-r] s1 s2			<span class="comment">#将s1拷贝到s2目录下,-r递归复制整个文件夹</span></span><br><span class="line">rm [-rf] 要删除的文件或目录	<span class="comment">#删除的文件或目录，-r递归删除整个文件夹，-f强制删除不提示</span></span><br><span class="line">mv oldName newName		<span class="comment">#重命名</span></span><br><span class="line">mv s1 s2			<span class="comment">#将s1文件或目录移动到s2目录下</span></span><br><span class="line">cat [-n] 文件			<span class="comment">#查看文件内容，-n显示行号，一般会带上管道命令|</span></span><br><span class="line">more 文件			<span class="comment">#ctrl+F：向下滚一屏；ctrl+B：返回上一屏；回车键：向下一行；q：离开more；=：输出当前行号</span></span><br><span class="line">less 文件			<span class="comment">#pagedown：向下翻一页；pageup：向上翻一页；/字串：向下搜索字串功能，n向下查找，N向上查找；q：离开</span></span><br><span class="line"><span class="built_in">echo</span> 输出内容			<span class="comment">#输出内容到控制台，也可以输出环静变量</span></span><br><span class="line">head -n 5 文件			<span class="comment">#查看文件开头的5行，不使用-n就是默认查找文件开头10行</span></span><br><span class="line">tail -n 5 文件			<span class="comment">#查看文件结尾的5行，不使用-n就是默认查找文件结尾10行</span></span><br><span class="line">tail -f 文件			<span class="comment">#实时追踪该文档的所有更新</span></span><br><span class="line">ls -l &gt; 文件			<span class="comment">#列表的内容覆盖写入文件中</span></span><br><span class="line">ls -l &gt;&gt; 文件			<span class="comment">#列表的内容追加写入文件结尾</span></span><br><span class="line"><span class="built_in">history</span> 10			<span class="comment">#显示最近使用过得10个历史命令</span></span><br></pre></td></tr></table></figure>



<h4 id="五-时间日期"><a href="#五-时间日期" class="headerlink" title="五.时间日期"></a>五.时间日期</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#时间日期类命令</span></span><br><span class="line">date <span class="string">&quot;+%Y-%m-%d %H:%M:%S&quot;</span>	<span class="comment">#显示年月日时分秒</span></span><br><span class="line">date -s <span class="string">&quot;2021-04-09 22:00:00&quot;</span>	<span class="comment">#设置系统当前时间</span></span><br><span class="line">cal				<span class="comment">#显示本月日历</span></span><br><span class="line">cal 2021			<span class="comment">#显示2021年日历</span></span><br></pre></td></tr></table></figure>



<h4 id="六-搜索查找"><a href="#六-搜索查找" class="headerlink" title="六.搜索查找"></a>六.搜索查找</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#搜索查找类命令</span></span><br><span class="line">find /home -name s1		<span class="comment">#根据名称递归查找/home目录下的s1文件</span></span><br><span class="line">find /opt -user root		<span class="comment">#查找/opt目录下，用户名为root的文件</span></span><br><span class="line">find / -size +100M		<span class="comment">#查找根目录下大与100M的文件</span></span><br><span class="line">s1 | s2				<span class="comment">#管道符，表示将s1命令处理的结果输出传递给后面的s2命令处理</span></span><br><span class="line">grep -ni <span class="string">&quot;hello&quot;</span> s1		<span class="comment">#在s1文件中查找hello，-n显示匹配行及行号，-i忽略字母大小写</span></span><br><span class="line">cat s1 | grep <span class="string">&quot;hello&quot;</span>		<span class="comment">#在s1文件中查找hello</span></span><br></pre></td></tr></table></figure>



<h4 id="七-压缩-amp-解压"><a href="#七-压缩-amp-解压" class="headerlink" title="七.压缩&amp;解压"></a>七.压缩&amp;解压</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#压缩&amp;解压命令</span></span><br><span class="line">gzip 文件			<span class="comment">#压缩文件</span></span><br><span class="line">gunzip 文件.gz			<span class="comment">#解压.gz文件</span></span><br><span class="line">zip -r 文件或目录			<span class="comment">#-r递归压缩目录及其子文件	</span></span><br><span class="line">unzip -d s1 文件.zip		<span class="comment">#将.zip解压到s1目录下，-d指定解压后文件的目录</span></span><br><span class="line">tar -zcvf s1.tar.gz 文件目录	<span class="comment">#将单个文件或多个文件或目录压缩为s1.tar.gz(-z：打包同时压缩；-c：产生.tar打包文件) </span></span><br><span class="line">tar -zxvf s1.tar.gz		<span class="comment">#将s1.tar.gz解压到当前目录(-x：解包.tar文件；-v：显示详细信息；-f：指定压缩后的文件名) </span></span><br></pre></td></tr></table></figure>



<h4 id="八-任务调度-amp-磁盘"><a href="#八-任务调度-amp-磁盘" class="headerlink" title="八.任务调度&amp;磁盘"></a>八.任务调度&amp;磁盘</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#任务调度</span></span><br><span class="line">crontab -elr			<span class="comment">#-e编辑crontab定时任务；-l查询crontab任务；-r删除当前用户所有的crontab任务，终止任务调度</span></span><br><span class="line">service crond restart		<span class="comment">#重启任务调度</span></span><br><span class="line">at [选项] [时间]			<span class="comment">#一次性定时计划任务</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#磁盘分区&amp;挂载</span></span><br><span class="line">lsblk [-f]			<span class="comment">#查看所有设备挂载情况</span></span><br><span class="line">df -h				<span class="comment">#查询系统整体磁盘使用情况</span></span><br><span class="line">du -hac --max-depth=1 /etc	<span class="comment">#查询/etc目录的磁盘占用情况，深度为1</span></span><br><span class="line">tree 目录			<span class="comment">#以树状显示目录结构</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h4 id="九-进程-amp-管理"><a href="#九-进程-amp-管理" class="headerlink" title="九.进程&amp;管理"></a>九.进程&amp;管理</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#进程&amp;管理命令</span></span><br><span class="line">ps -aux			<span class="comment">#查询所有进程</span></span><br><span class="line">ps -aux | grep X	<span class="comment">#查询有没有x进程</span></span><br><span class="line">ps -ef			<span class="comment">#查询所有进程</span></span><br><span class="line">ps -ef | grep X		<span class="comment">#查询有没有x进程</span></span><br><span class="line"><span class="built_in">kill</span> -9 x		<span class="comment">#强制终止x进程号的进程</span></span><br><span class="line">killall x		<span class="comment">#强制终止x进程名称的进程</span></span><br><span class="line">pstree -pu			<span class="comment">#以树状显示所有进程信息</span></span><br><span class="line">pstree -pu x		<span class="comment">#以树状显示x进程信息(-p:显示进程的pid，-u:显示进程的所属用户)</span></span><br><span class="line">setup				<span class="comment">#查看服务</span></span><br><span class="line">systemctl [start|stop|restart|status] 服务名	<span class="comment">#systemctl管理的服务在/usr/lib/systemd/system</span></span><br><span class="line">systemctl list-unit-files [|服务名] 	<span class="comment">#查看服务开机启动状态</span></span><br><span class="line">systemctl <span class="built_in">enable</span> 服务名		<span class="comment">#设置服务开机启动</span></span><br><span class="line">systemctl <span class="built_in">disable</span> 服务名		<span class="comment">#关闭服务开机启动</span></span><br><span class="line">systemctl is-enabled 服务名	<span class="comment">#查询服务是否是自启动的</span></span><br></pre></td></tr></table></figure>





<h4 id="十-firewall-amp-网络"><a href="#十-firewall-amp-网络" class="headerlink" title="十.firewall&amp;网络"></a>十.firewall&amp;网络</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#firewall命令</span></span><br><span class="line">firewall-cmd --permanent --add-port=端口号/协议	<span class="comment">#打开端口</span></span><br><span class="line">firewall-cmd --permanent --remove-port=端口号/协议	<span class="comment">#关闭端口</span></span><br><span class="line">firewall-cmd --reload		<span class="comment">#重新载入</span></span><br><span class="line">firewall-cmd --query-port=端口号/协议	<span class="comment">#查询端口是否开放</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#监控网络命令</span></span><br><span class="line">netstat -anp [|grep ]	<span class="comment">#查看系统网络情况(-an:按一定顺序排列输出，-p:显示哪个进程在调用)</span></span><br></pre></td></tr></table></figure>





<h4 id="十一-rpm-amp-yum"><a href="#十一-rpm-amp-yum" class="headerlink" title="十一.rpm&amp;yum"></a>十一.rpm&amp;yum</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#rpm&amp;yum命令</span></span><br><span class="line">rpm -qa			<span class="comment">#查询所安装的所有rpm软件包</span></span><br><span class="line">rpm -qa | grep 软件包		<span class="comment">#查询指定的rpm软件包</span></span><br><span class="line">rpm -qi 软件包			<span class="comment">#查询软件包信息</span></span><br><span class="line">rpm -ql 软件包			<span class="comment">#查询软件包中的文件</span></span><br><span class="line">rpm -ivh 软件包			<span class="comment">#安装软件包(i:install安装，v:verbose提示，h:hash进度条)</span></span><br><span class="line">rpm -e 软件包			<span class="comment">#卸载软件包</span></span><br><span class="line">yum install 包名		<span class="comment">#安装指定包</span></span><br><span class="line">yum update 包名		<span class="comment">#更新指定包</span></span><br><span class="line">yum remove 包名		<span class="comment">#删除软件包</span></span><br><span class="line">yum search 包名		<span class="comment">#查找软件包</span></span><br><span class="line">yum list			<span class="comment">#列出所有可安装的软件包清单</span></span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>命令</tag>
      </tags>
  </entry>
  <entry>
    <title>mybatisplus</title>
    <url>/post/ac57c2de/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>mybatisplus</category>
      </categories>
      <tags>
        <tag>数据类型</tag>
        <tag>事务</tag>
        <tag>jedis</tag>
      </tags>
  </entry>
  <entry>
    <title>nosql认识</title>
    <url>/post/d1b72ac1/</url>
    <content><![CDATA[<span id="more"></span>



<h3 id="一-NoSQL的介绍"><a href="#一-NoSQL的介绍" class="headerlink" title="一.NoSQL的介绍"></a>一.NoSQL的介绍</h3><ul>
<li><strong>NoSQL</strong>（<strong>N</strong>ot <strong>o</strong>nly <strong>SQL</strong>），是对不同于传统的<a href="https://zh.wikipedia.org/wiki/%E9%97%9C%E8%81%AF%E5%BC%8F%E8%B3%87%E6%96%99%E5%BA%AB">关系数据库</a>的<a href="https://zh.wikipedia.org/wiki/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F">数据库管理系统</a>的统称。</li>
<li>NoSQL用于超大规模数据的存储。这些类型的数据存储不需要固定的模式，无需多余操作就可以横向扩展。</li>
</ul>
<h3 id="二"><a href="#二" class="headerlink" title="二."></a>二.</h3>]]></content>
      <categories>
        <category>nosql</category>
      </categories>
      <tags>
        <tag>nosql</tag>
        <tag>了解</tag>
        <tag>CAP</tag>
      </tags>
  </entry>
  <entry>
    <title>mybatis</title>
    <url>/post/15832afd/</url>
    <content><![CDATA[<span id="more"></span>

<h3 id="一-介绍"><a href="#一-介绍" class="headerlink" title="一. 介绍"></a>一. 介绍</h3><h4 id="1-什么是mybatis"><a href="#1-什么是mybatis" class="headerlink" title="1. 什么是mybatis"></a>1. 什么是mybatis</h4><ul>
<li>mybatis 是一个半 ORM (对象关系映射)框架，内部封装了 JDBC 流程，开发时只需要关注 SQL 语句本身。</li>
<li>可以使用 XML 或注解来配置和映射 SQL 语句，将 pojo 映射成数据库中的记录，避免几乎所有 JDBC 代码和手动设置参数以及获取结果集。</li>
<li>通过 XML 文件或注解的方式将要执行的各种 SQL 语句管理起来。</li>
</ul>
<h4 id="2-mybatis-的优缺点"><a href="#2-mybatis-的优缺点" class="headerlink" title="2. mybatis 的优缺点"></a>2. mybatis 的优缺点</h4><ul>
<li>优点<ul>
<li>与 JDBC 相比，减少了很多模板代码，也不需要管理数据库连接。</li>
<li>基于 SQL 语句编程，SQL 语句写在 XML 文件里，与应用程序解耦，便于统一管理。</li>
<li>提供 XML 标签，支持编写动态 SQL 语句，并可重用。</li>
</ul>
</li>
<li>缺点<ul>
<li>SQL 语句的编写工作量较大，尤其是字段多、关系表多时，对开发人员编写 SQL 语句有一定要求。</li>
</ul>
</li>
</ul>
<h3 id="二-mybatis原理"><a href="#二-mybatis原理" class="headerlink" title="二. mybatis原理"></a>二. mybatis原理</h3><ul>
<li><p>配置基础配置XML，如 SqlMapConfig.xml。</p>
</li>
<li><p>配置映射器XML，如 mapper.xml。</p>
</li>
<li><p>解析XML，SqlSessionFactoryBuilder 构建出 SqlSessionFactory 对象。</p>
</li>
<li><p>SqlSessionFactory 产生 SqlSession 对象。</p>
<ul>
<li><p>Executor：执行器，由它统一调度其他三个对象来执行对应的SQL</p>
</li>
<li><p>StatementHandler：使用数据库的Statement执行操作</p>
</li>
<li><p>ParameterHandler：用于SQL对参数的处理</p>
</li>
<li><p>ResultHandler：进行最后数据集的封装返回处理</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 读取配置文件</span></span><br><span class="line">String resource = <span class="string">&quot;SqlMapConfig.xml&quot;</span>;</span><br><span class="line">InputStream inputStream = Resources.getResourceAsStream(resource);</span><br><span class="line"><span class="comment">// 使用SqlSessionFactoryBuilder从xml配置文件中创建SqlSessionFactory</span></span><br><span class="line">SqlSessionFactory sqlSessionFactory = <span class="keyword">new</span> SqlSessionFactoryBuilder().build(inputStream);</span><br><span class="line"><span class="comment">// 创建数据库会话实例sqlSession</span></span><br><span class="line">SqlSession sqlSession = sqlSessionFactory.openSession();</span><br><span class="line"><span class="comment">// 查询单个/多个记录，根据用户id查询用户信息(namespace.select的id)</span></span><br><span class="line">User user = sqlSession.selectOne(<span class="string">&quot;userDao.findUserById&quot;</span>, <span class="number">10</span>);</span><br><span class="line">List&lt;User&gt; list = sqlSession.selectList(<span class="string">&quot;userDao.findUserByName&quot;</span>,<span class="string">&quot;小明&quot;</span>);</span><br><span class="line"><span class="comment">// 插入user用户的信息</span></span><br><span class="line">sqlSession.insert(<span class="string">&quot;userDao.insertUser&quot;</span>, user);</span><br><span class="line"><span class="comment">// 删除用户</span></span><br><span class="line">sqlSession.delete(<span class="string">&quot;userDao.deleteUserById&quot;</span>,<span class="number">18</span>);</span><br><span class="line"><span class="comment">// 更新用户</span></span><br><span class="line">sqlSession.update(<span class="string">&quot;userDao.updateUser&quot;</span>, user);</span><br><span class="line"><span class="comment">// 提交事务</span></span><br><span class="line">sqlSession.commit();</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h3 id="三-开发方式"><a href="#三-开发方式" class="headerlink" title="三.开发方式"></a>三.开发方式</h3><h4 id="1-原始DAO开发"><a href="#1-原始DAO开发" class="headerlink" title="1. 原始DAO开发"></a>1. 原始DAO开发</h4><ul>
<li><p>编写 DAO 接口类</p>
</li>
<li><p>编写 DAO 实现类，实现类注入成员属性 sqlSessionFactory</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> User <span class="title">findUserById</span><span class="params">(Integer id)</span> </span>&#123;</span><br><span class="line">    SqlSession sqlSession = sqlSessionFactory.openSession();</span><br><span class="line">    User user = sqlSession.selectOne(<span class="string">&quot;userDao.findUserById&quot;</span>, id);</span><br><span class="line">    <span class="comment">// 释放资源</span></span><br><span class="line">    sqlSession.close();</span><br><span class="line">    <span class="keyword">return</span> user;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//缺点：由于SQLSession是线程不安全的，所以必须放在方法内，但同时就导致方法内有很多重复冗余的代码。</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="2-mapper代理开发"><a href="#2-mapper代理开发" class="headerlink" title="2. mapper代理开发"></a>2. mapper代理开发</h4><ul>
<li>编写 mapper.xml。</li>
<li>编写 mapper 接口（类似于DAO接口）。</li>
<li>通过 SqlSession.getMapper (接口名.class) 获取实现了该接口的代理类实例，即DAO实例。</li>
<li>两者需要遵循一些规范才能生效<ul>
<li>Mapper.xml 文件中的 namespace 与 mapper 接口的类全限定名相同</li>
<li>Mapper接口方法名和 Mapper.xml 中定义的每个statement的id相同</li>
<li>Mapper接口方法的输入参数类型和 mapper.xml 中定义的每个 SQL 的 parameterType 的类型相同</li>
<li>Mapper接口方法的输出参数类型和 mapper.xml 中定义的每个 SQL 的 resultType 的类型相同</li>
</ul>
</li>
</ul>
<h3 id="四-核心配置文件"><a href="#四-核心配置文件" class="headerlink" title="四. 核心配置文件"></a>四. 核心配置文件</h3><ul>
<li><p><a href="http://www.mybatis.org/mybatis-3/zh/configuration.html">核心配置文件的官方文档</a></p>
</li>
<li><p>db.properties</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">driver</span>=<span class="string">com.mysql.jdbc.Driver</span></span><br><span class="line"><span class="attr">url</span>=<span class="string">jdbc:mysql://localhost:3306/mybatis?useUnicode=true&amp;characterEncoding=UTF-8</span></span><br><span class="line"><span class="attr">username</span>=<span class="string">root</span></span><br><span class="line"><span class="attr">password</span>=<span class="string">password</span></span><br></pre></td></tr></table></figure></li>
<li><p>核心配置文件</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">configuration</span></span></span><br><span class="line"><span class="meta">        <span class="meta-keyword">PUBLIC</span> <span class="meta-string">&quot;-//mybatis.org//DTD Config 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">        <span class="meta-string">&quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--核心配置文件--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span> <span class="attr">resource</span>=<span class="string">&quot;db.properties&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">environments</span> <span class="attr">default</span>=<span class="string">&quot;development&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">environment</span> <span class="attr">id</span>=<span class="string">&quot;development&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">transactionManager</span> <span class="attr">type</span>=<span class="string">&quot;JDBC&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dataSource</span> <span class="attr">type</span>=<span class="string">&quot;POOLED&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driver&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;driver&#125;&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;url&#125;&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;username&#125;&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;password&#125;&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dataSource</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">environment</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">environments</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--每一个Mapper.xml文件都需要在Mybatis核心配置文件中注册--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">resource</span>=<span class="string">&quot;UserMapper.xml&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="五-映射文件"><a href="#五-映射文件" class="headerlink" title="五. 映射文件"></a>五. 映射文件</h3><ul>
<li><a href="https://mybatis.org/mybatis-3/zh/sqlmap-xml.html">映射文件的官方文档</a></li>
</ul>
<h4 id="1-映射文件"><a href="#1-映射文件" class="headerlink" title="1. 映射文件"></a>1. 映射文件</h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">mapper</span> <span class="meta-keyword">PUBLIC</span> <span class="meta-string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- mapper:根标签，namespace：命名空间，随便写，一般保证命名空间唯一 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;cn.itcast.mybatis.mapper.UserMapper&quot;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 添加用户 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">insert</span>  <span class="attr">id</span>=<span class="string">&quot;insertUser&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;com.wyp.pojo.User&quot;</span>&gt;</span></span><br><span class="line">    insert into user(id,username,birthday,sex,address) values(#&#123;id&#125;,#&#123;username&#125;,#&#123;birthday&#125;,#&#123;sex&#125;,#&#123;address&#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 删除用户 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">delete</span> <span class="attr">id</span>=<span class="string">&quot;deleteUserById&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;int&quot;</span>&gt;</span></span><br><span class="line">    delete from user where id=#&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">delete</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 更新用户 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">update</span> <span class="attr">id</span>=<span class="string">&quot;updateUser&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;com.wyp.pojo.User&quot;</span>&gt;</span></span><br><span class="line">    update user set username=#&#123;username&#125;,birthday=#&#123;birthday&#125;, sex=#&#123;sex&#125;,address=#&#123;address&#125; where id=#&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">update</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 查询用户，也可以用resultMap来映射返回值 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;findUserById&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;int&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;com.wyp.pojo.User&quot;</span>&gt;</span></span><br><span class="line">    select * from user where id = #&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h4 id="2-和"><a href="#2-和" class="headerlink" title="2. #{}和${}"></a>2. #{}和${}</h4><ul>
<li><p><strong>#{}</strong> 占位符</p>
<ul>
<li>进行 java 类型和 jdbc 类型转换</li>
<li>传值时会带<code>&quot;&quot;</code></li>
<li>如果 parameterType 传入的是pojo类型，那么 <code>#&#123;&#125; </code>中的变量名称必须是 pojo 中对应的属性</li>
<li>如果 parameterType 传入的是基础类型值，<code>#&#123;&#125;</code> 括号中可以是 value 或其它名称</li>
<li>可以有效防止 sql 注入</li>
</ul>
</li>
<li><p><strong>${}</strong> 占位符</p>
<ul>
<li>不进行 java 类型和 jdbc 类型转换</li>
<li>传值时不带<code>&quot;&quot;</code></li>
<li>如果 parameterType 传入的是pojo类型，那么 <code>$&#123;&#125;</code> 中的变量名称必须是 pojo 中对应的属性</li>
<li>如果 parameterType 传输单个简单类型值，<code>$&#123;&#125;</code> 括号中只能是 value</li>
</ul>
</li>
<li><p>使用情景</p>
<ul>
<li>mybatis 排序时使用 order by 动态参数时需要注意，使用<code>$&#123;&#125;</code>而不用<code>#&#123;&#125;</code></li>
<li>模糊查询：<code>LIKE CONCAT(&#39;%&#39;,#&#123;value&#125;,&#39;%&#39;)</code> 或 <code>LIKE &#39;%$&#123;value&#125;%&#39;</code></li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>mybatis</category>
      </categories>
      <tags>
        <tag>配置文件</tag>
      </tags>
  </entry>
  <entry>
    <title>redis初学</title>
    <url>/post/7b25d017/</url>
    <content><![CDATA[<span id="more"></span>

<h3 id="一-redis介绍"><a href="#一-redis介绍" class="headerlink" title="一. redis介绍"></a>一. redis介绍</h3><ul>
<li><p>REmote DIctionary Server(Redis) 是一个 key-value 存储系统，是跨平台的非关系型数据库。</p>
</li>
<li><p>Redis 是一个开源的使用 ANSI C 语言编写、遵守 BSD 协议、支持网络、可基于内存、分布式、可选持久性的键值对(Key-Value)存储数据库，并提供多种语言的 API。</p>
</li>
<li><p>Redis 通常被称为数据结构服务器，因为值（value）可以是字符串(String)、哈希(Hash)、列表(list)、集合(sets)和有序集合(sorted sets)等类型。</p>
</li>
<li><p>Redis 中有5大数据类型，3大特殊数据类型。</p>
</li>
</ul>
<h3 id="二-redis-命令"><a href="#二-redis-命令" class="headerlink" title="二. redis 命令"></a>二. redis 命令</h3><ul>
<li><p>启动 redis 服务器，打开终端并输入命令 <strong>redis-cli</strong>，该命令会连接本地的 redis 服务。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ redis-cli</span><br><span class="line">redis 127.0.0.1:6379&gt;</span><br><span class="line">redis 127.0.0.1:6379&gt; PIN</span><br><span class="line">PONG</span><br></pre></td></tr></table></figure></li>
<li><p>如果需要在远程 redis 服务上执行命令，同样我们使用的也是 <strong>redis-cli</strong> 命令。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ redis-cli -h host -p port -a password</span><br></pre></td></tr></table></figure></li>
<li><p>键的命令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">DEL KEY_NAME		<span class="comment">#删除已存在的键。不存在的 key 会被忽略</span></span><br><span class="line">DUMP KEY_NAME		<span class="comment">#序列化给定的 key ，并返回被序列化的值</span></span><br><span class="line">EXISTS KEY_NAME		<span class="comment">#检查给定 key 是否存在</span></span><br><span class="line">Expire KEY_NAME TIME_IN_SECONDS		<span class="comment">#设置 key 的过期时间，key 过期后将不再可用（单位以秒计）</span></span><br><span class="line">Expireat KEY_NAME UNIX_TIME		<span class="comment">#以 UNIX 时间戳(unix timestamp)格式设置 key 的过期时间</span></span><br><span class="line">PEXPIRE KEY_NAME milliseconds		<span class="comment">#以毫秒为单位设置 key 的生存时间</span></span><br><span class="line">PEXPIREAT KEY_NAME UNIX_milliseconds		<span class="comment">#以 UNIX 时间戳</span></span><br><span class="line">PTTL KEY_NAME		<span class="comment">#以毫秒为单位返回 key 的剩余过期时间</span></span><br><span class="line">TTL KEY_NAME		<span class="comment">#以秒为单位返回 key 的剩余过期时间</span></span><br><span class="line">PERSIST KEY_NAME		<span class="comment">#移除给定 key 的过期时间，使得 key 永不过期</span></span><br><span class="line">KEYS PATTERN		<span class="comment">#查找所有符合给定模式 pattern 的 key </span></span><br><span class="line">MOVE KEY_NAME DB		<span class="comment">#将当前数据库的 key 移动到给定的数据库 db 当中，当前数据库就没有这个 key 了</span></span><br><span class="line">RANDOMKEY		<span class="comment">#从当前数据库中随机返回一个 key</span></span><br><span class="line">RENAME OLD_KEY_NAME NEW_KEY_NAME		<span class="comment">#修改 key 的名称 </span></span><br><span class="line">RENAMENX OLD_KEY_NAME NEW_KEY_NAME		<span class="comment">#在新的 key 不存在时修改 key 的名称</span></span><br><span class="line">TYPE KEY_NAME 		<span class="comment">#返回 key 所储存的值的类型</span></span><br><span class="line">SCAN cursor [MATCH pattern] [COUNT count]		<span class="comment">#迭代数据库中的数据库键，cursor - 游标，pattern - 匹配的模式，count - 指定从数据集里返回多少元素，默认值为 10 ，</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="三-数据类型"><a href="#三-数据类型" class="headerlink" title="三. 数据类型"></a>三. 数据类型</h3><h4 id="1-String（字符串）"><a href="#1-String（字符串）" class="headerlink" title="1. String（字符串）"></a>1. String（字符串）</h4><ul>
<li><p>string 是 redis 最基本的类型，你可以理解成与 Memcached 一模一样的类型，一个 key 对应一个 value。</p>
</li>
<li><p>string 类型是二进制安全的。意思是 redis 的 string 可以包含任何数据。比如jpg图片或者序列化的对象。</p>
</li>
<li><p>string 类型是 Redis 最基本的数据类型，string 类型的值最大能存储 512MB。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">SET KEY_NAME VALUE		<span class="comment">#设置给定 key 的值，如果 key 已经存储其他值， SET 就覆写旧值，且无视类型</span></span><br><span class="line">GET KEY_NAME		<span class="comment">#获取指定 key 的值。如果 key 不存在，返回 nil ，如果key 储存的值不是字符串类型，返回一个错误</span></span><br><span class="line">GETRANGE KEY_NAME start end		<span class="comment">#获取存储在指定 key 中字符串的子字符串</span></span><br><span class="line">SETRANGE KEY_NAME OFFSET VALUE		<span class="comment">#用指定的字符串覆盖给定 key 所储存的字符串值，覆盖的位置从偏移量 offset 开始</span></span><br><span class="line">GETSET KEY_NAME VALUE		<span class="comment">#设置指定 key 的值，并返回 key 的旧值</span></span><br><span class="line">SETNX KEY_NAME VALUE		<span class="comment">#指定的 key 不存在时，为 key 设置指定的值</span></span><br><span class="line">SETEX KEY_NAME TIMEOUT VALUE		<span class="comment">#为指定的 key 设置值及其过期时间。如果 key 已经存在， SETEX 命令将会替换旧的值</span></span><br><span class="line">PSETEX key1 EXPIRY_IN_MILLISECONDS value1		<span class="comment">#以毫秒为单位设置 key 的生存时间</span></span><br><span class="line">STRLEN KEY_NAME			<span class="comment">#获取指定 key 所储存的字符串值的长度</span></span><br><span class="line">MSET key1 value1 key2 value2 .. keyN valueN		<span class="comment">#同时设置一个或多个 key-value 对</span></span><br><span class="line">MGET KEY1 KEY2 .. KEYN		<span class="comment">#返回所有(一个或多个)给定 key 的值</span></span><br><span class="line">MSETNX key1 value1 key2 value2 .. keyN valueN 		<span class="comment">#所有给定 key 都不存在时，同时设置一个或多个 key-value 对</span></span><br><span class="line">INCR KEY_NAME		<span class="comment">#将 key 中储存的数字值增一</span></span><br><span class="line">INCRBY KEY_NAME INCR_AMOUNT		<span class="comment">#将 key 中储存的数字加上指定的增量值</span></span><br><span class="line">INCRBYFLOAT KEY_NAME INCR_AMOUNT		<span class="comment">#为 key 中所储存的值加上指定的浮点数增量值</span></span><br><span class="line">DECR KEY_NAME 		<span class="comment">#将 key 中储存的数字值减一</span></span><br><span class="line">DECRBY KEY_NAME DECREMENT_AMOUNT		<span class="comment">#将 key 所储存的值减去指定的减量值</span></span><br><span class="line">APPEND KEY_NAME NEW_VALUE		<span class="comment">#用于为指定的 key 追加值，如果 key 已经存在并且是一个字符串， APPEND 命令将 value 追加到 key 原来的值的末尾。如果 key 不存在， APPEND 就简单地将给定 key 设为 value ，就像执行 SET key value 一样。</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="2-Hash（哈希）"><a href="#2-Hash（哈希）" class="headerlink" title="2. Hash（哈希）"></a>2. Hash（哈希）</h4><ul>
<li><p>键值对集合,即编程语言中的Map类型。</p>
</li>
<li><p>适合存储对象,并且可以像数据库中update一个属性一样只修改某一项属性值。</p>
</li>
<li><p>使用场景：存储、读取、修改用户属性。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">HSET KEY_NAME FIELD VALUE		<span class="comment">#为哈希表中的字段赋值</span></span><br><span class="line">HSETNX KEY_NAME FIELD VALUE		<span class="comment">#为哈希表中不存在的的字段赋值，如果字段已经存在于哈希表中，操作无效。</span></span><br><span class="line">HGET KEY_NAME FIELD_NAME 		<span class="comment">#返回哈希表中指定字段的值</span></span><br><span class="line">HGETALL KEY_NAME		<span class="comment">#返回哈希表中，所有的字段和值</span></span><br><span class="line">HEXISTS KEY_NAME FIELD_NAME		<span class="comment">#查看哈希表的指定字段是否存在</span></span><br><span class="line">HDEL KEY_NAME FIELD1.. FIELDN		<span class="comment">#用于删除哈希表 key 中的一个或多个指定字段，不存在的字段将被忽略</span></span><br><span class="line">HINCRBY KEY_NAME FIELD_NAME INCR_BY_NUMBER		<span class="comment">#为哈希表中的字段值加上指定增量值</span></span><br><span class="line">HINCRBYFLOAT key field increment		<span class="comment">#为哈希表中的字段值加上指定浮点数增量值，如果不存在，在执行命令前，字段的值被初始化为 0 </span></span><br><span class="line">HKEYS key		<span class="comment">#获取哈希表中的所有域（field）</span></span><br><span class="line">HVALS KEY_NAME FIELD VALUE		<span class="comment">#返回哈希表所有域(field)的值</span></span><br><span class="line">HLEN KEY_NAME 		<span class="comment">#获取哈希表中字段的数量</span></span><br><span class="line">HMGET KEY_NAME FIELD1...FIELDN		<span class="comment">#返回哈希表中，一个或多个给定字段的值</span></span><br><span class="line">HMSET KEY_NAME FIELD1 VALUE1 ...FIELDN VALUEN		<span class="comment">#用于同时将多个 field-value (字段-值)对设置到哈希表中,此命令会覆盖哈希表中已存在的字段。如果哈希表不存在，会创建一个空哈希表，并执行 HMSET 操作</span></span><br><span class="line">HSCAN key cursor [MATCH pattern] [COUNT count]		<span class="comment">#迭代哈希表中的键值对</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="3-List（列表）"><a href="#3-List（列表）" class="headerlink" title="3. List（列表）"></a>3. List（列表）</h4><ul>
<li><p>链表(双向链表)，增删快,提供了操作某一段元素的API。</p>
</li>
<li><p>使用场景：最新消息排行等功能(比如朋友圈的时间线) ；消息队列。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">LPUSH KEY_NAME VALUE1.. VALUEN		<span class="comment">#将一个或多个值插入到列表头部。 如果 key 不存在，一个空列表会被创建并执行</span></span><br><span class="line">LPUSHX KEY_NAME VALUE1.. VALUEN		<span class="comment">#将一个值插入到已存在的列表头部，列表不存在时操作无效</span></span><br><span class="line">Lpop KEY_NAME		<span class="comment">#移除并返回列表的第一个元素</span></span><br><span class="line">LRANGE KEY_NAME START END		<span class="comment">#返回列表中指定区间内的元素，区间以偏移量 START 和 END 指定，可以使用负数下标</span></span><br><span class="line">RPUSH KEY_NAME VALUE1..VALUEN		<span class="comment">#将一个或多个值插入到列表的尾部(最右边)</span></span><br><span class="line">RPUSHX KEY_NAME VALUE		<span class="comment">#将一个值插入到已存在的列表尾部(最右边)。如果列表不存在，操作无效</span></span><br><span class="line">RPOP KEY_NAME		<span class="comment">#用于移除列表的最后一个元素，返回值为移除的元素</span></span><br><span class="line">RPOPLPUSH SOURCE_KEY_NAME DESTINATION_KEY_NAME		<span class="comment">#用于移除列表的最后一个元素，并将该元素添加到另一个列表并返回</span></span><br><span class="line">BLPOP LIST1 ... TIMEOUT		<span class="comment">#移出并获取列表的第一个元素，如果列表没有元素会阻塞列表直到等待超时或发现可弹出元素为止</span></span><br><span class="line">BRPOP LIST1 LIST2 .. LISTN TIMEOUT		<span class="comment">#出并获取列表的最后一个元素,如果列表没有元素..</span></span><br><span class="line">BRPOPLPUSH LIST1 ANOTHER_LIST TIMEOUT		<span class="comment">#从列表中取出最后一个元素，并插入到另外一个列表的头部,如果列表没有元素..</span></span><br><span class="line">LLEN KEY_NAME		<span class="comment">#返回列表的长度。 如果列表 key 不存在，则 key 被解释为一个空列表，返回 0</span></span><br><span class="line">LINDEX KEY_NAME INDEX_POSITION		<span class="comment">#通过索引获取列表中的元素。以 -1 表示列表的最后一个元素，-2 表示列表的倒数第二个</span></span><br><span class="line">LINSERT key BEFORE|AFTER pivot value		<span class="comment">#在列表的元素前或者后插入元素</span></span><br><span class="line">LSET KEY_NAME INDEX VALUE		<span class="comment">#通过索引来设置元素的值</span></span><br><span class="line">LTRIM KEY_NAME START STOP		<span class="comment">#对一个列表进行修剪(trim)，就是说，让列表只保留指定区间内的元素</span></span><br><span class="line">LREM key count VALUE		<span class="comment">#根据参数 COUNT 的值，移除列表中与参数 VALUE 相等的元素</span></span><br><span class="line">							<span class="comment">#count &gt; 0 : 从表头开始向表尾搜索，移除与 VALUE 相等的元素，数量为 COUNT 。</span></span><br><span class="line">							<span class="comment">#count &lt; 0 : 从表尾开始向表头搜索，移除与 VALUE 相等的元素，数量为 COUNT 的绝对值。</span></span><br><span class="line">							<span class="comment">#count = 0 : 移除表中所有与 VALUE 相等的值。</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="4-Set（集合）"><a href="#4-Set（集合）" class="headerlink" title="4. Set（集合）"></a>4. Set（集合）</h4><ul>
<li><p>Redis 的 Set 是 string 类型的无序集合。</p>
</li>
<li><p>集合是通过哈希表实现的，所以添加，删除，查找的复杂度都是 O(1)，为集合提供了求交集、并集、差集等操作。</p>
</li>
<li><p>使用场景：共同好友 ；利用唯一性,统计访问网站的所有独立ip ；好友推荐时,根据tag求交集,大于某个阈值就可以推荐。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">SADD KEY_NAME VALUE1..VALUEN		<span class="comment">#将一个或多个成员元素加入到集合中，已经存在于集合的成员元素将被忽略</span></span><br><span class="line">SCARD KEY_NAME		<span class="comment">#返回集合中元素的数量</span></span><br><span class="line">SISMEMBER KEY VALUE		<span class="comment">#判断成员元素是否是集合的成员</span></span><br><span class="line">SMEMBERS key		<span class="comment">#返回集合中的所有的成员</span></span><br><span class="line">SMOVE SOURCE DESTINATION MEMBER		<span class="comment">#指定成员 member 元素从 source 集合移动到 destination集合,SMOVE是原子性操作</span></span><br><span class="line">SPOP key [count]		<span class="comment">#移除集合中的指定 key 的一个或多个随机元素，移除后会返回移除的元素</span></span><br><span class="line">SRANDMEMBER KEY [count]		<span class="comment">#用于返回集合中的一个随机元素</span></span><br><span class="line">SREM KEY MEMBER1..MEMBERN		<span class="comment">#移除集合中的一个或多个成员元素，不存在的成员元素会被忽略</span></span><br><span class="line">SDIFF FIRST_KEY OTHER_KEY1..OTHER_KEYN		<span class="comment">#返回第一个集合与其他集合之间的差异，也可以认为说第一个集合中独有的元素</span></span><br><span class="line">SINTER KEY KEY1..KEYN		<span class="comment">#返回给定所有给定集合的交集</span></span><br><span class="line">SUNION KEY KEY1..KEYN		<span class="comment">#返回给定集合的并集。不存在的集合 key 被视为空集</span></span><br><span class="line">SUNIONSTORE destination key [key ...]		<span class="comment">#将给定集合的并集存储在指定的集合 destination 中</span></span><br><span class="line">SSCAN key cursor [MATCH pattern] [COUNT count]		<span class="comment">#迭代集合中键的元素</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="5-ZSet（sorted-set：有序集合）"><a href="#5-ZSet（sorted-set：有序集合）" class="headerlink" title="5.ZSet（sorted set：有序集合）"></a>5.ZSet（sorted set：有序集合）</h4><ul>
<li><p>zset 和 set 一样也是string类型元素的集合,且不允许重复的成员。不同的是每个元素都会关联一个double类型的权重参数score。redis正是通过score来为集合中的成员进行从小到大的排序。</p>
</li>
<li><p>数据插入集合时,已经进行天然排序，zset的成员是唯一的,但分数(score)却可以重复。</p>
</li>
<li><p>使用场景：排行榜 ；带权重的消息队列。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ZADD KEY_NAME SCORE1 VALUE1.. SCOREN VALUEN		<span class="comment">#向有序集合添加一个或多个成员，或者更新已存在成员的分数</span></span><br><span class="line">ZCARD KEY_NAME		<span class="comment">#计算集合中元素的数量</span></span><br><span class="line">ZCOUNT key min max		<span class="comment">#计算在有序集合中指定区间分数的成员数</span></span><br><span class="line">ZINCRBY key increment member		<span class="comment">#对有序集合中指定成员的分数加上增量 increment</span></span><br><span class="line">ZINTERSTORE destination numkeys key [key ...] [WEIGHTS weight [weight ...]] [AGGREGATE SUM|MIN|MAX]</span><br><span class="line"><span class="comment">#算给定的一个或多个有序集的交集，其中给定 key 的数量必须以 numkeys 参数指定，并将该交集(结果集)储存到 destination </span></span><br><span class="line">ZLEXCOUNT KEY MIN MAX		<span class="comment">#计算有序集合中指定字典区间内成员数量</span></span><br><span class="line">ZRANGE key start stop [WITHSCORES]		<span class="comment">#返回有序集中，指定区间内的成员</span></span><br><span class="line">ZRANGEBYLEX key min max [LIMIT offset count]		<span class="comment">#通过字典区间返回有序集合的成员</span></span><br><span class="line">ZRANGEBYSCORE key min max [WITHSCORES] [LIMIT offset count]		<span class="comment">#返回有序集合中指定分数区间的成员列表</span></span><br><span class="line">ZRANK key member		<span class="comment">#返回有序集合中指定成员的索引</span></span><br><span class="line">ZREM key member [member ...]		<span class="comment">#移除有序集合中的一个或多个成员，不存在的成员将被忽略</span></span><br><span class="line">ZREMRANGEBYLEX key min max		<span class="comment">#移除有序集合中给定的字典区间的所有成员</span></span><br><span class="line">ZREMRANGEBYRANK key start stop		<span class="comment">#移除有序集中，指定排名(rank)区间内的所有成员</span></span><br><span class="line">ZREMRANGEBYSCORE key min max		<span class="comment">#移除有序集中，指定分数（score）区间内的所有成员</span></span><br><span class="line">ZREVRANGE key start stop [WITHSCORES]		<span class="comment">#返回有序集中，指定区间内的成员，按分数值递减(从大到小)来排列</span></span><br><span class="line">ZREVRANGEBYSCORE key max min [WITHSCORES] [LIMIT offset count]		<span class="comment">#返回有序集中指定分数区间内的所有的成员</span></span><br><span class="line">ZREVRANK key member		<span class="comment">#返回有序集中成员的排名。其中有序集成员按分数值递减(从大到小)排序。</span></span><br><span class="line">ZSCORE key member		<span class="comment">#返回有序集中，成员的分数值。 如果成员元素不是有序集 key 的成员，或 key 不存在，返回 nil</span></span><br><span class="line">ZUNIONSTORE destination numkeys key [key ...] [WEIGHTS weight [weight ...]] [AGGREGATE SUM|MIN|MAX]</span><br><span class="line"><span class="comment">#计算给定的一个或多个有序集的并集，其中给定 key 的数量必须以 numkeys 参数指定，并将该并集(结果集)储存到 destination</span></span><br><span class="line">ZSCAN key cursor [MATCH pattern] [COUNT count]		<span class="comment">#迭代有序集合中的元素（包括元素成员和元素分值）</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="6-Geospatial"><a href="#6-Geospatial" class="headerlink" title="6. Geospatial"></a>6. Geospatial</h4><ul>
<li><p>Redis 的 GEO 特性在 Redis 3.2 版本中推出， 这个功能可以将用户给定的地理位置信息储存起来， 并对这些信息进行操作。</p>
</li>
<li><p>GEO 底层的实现原理其实就是 Zset！我们可以使用Zset命令来操作geo</p>
</li>
<li><p>有效的经度从-180度到180度。</p>
</li>
<li><p>有效的纬度从-85.05112878度到85.05112878度。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">geoadd key longitud(经度) latitude(纬度) member	[member..]	<span class="comment">#将一个/多个具体经纬度的坐标存入一个有序集合</span></span><br><span class="line">geopos key member [member..]		<span class="comment">#获取集合中的一个/多个成员坐标</span></span><br><span class="line">geodist key member1 member2 [unit]		<span class="comment">#返回两个给定位置之间的距离，unit：m、km、mi 英里、ft 英尺</span></span><br><span class="line">georadius key longitude latitude radius m|km|mi|ft [WITHCOORD][WITHDIST] [WITHHASH] [COUNT count]</span><br><span class="line"><span class="comment">#以给定的经纬度为中心， 返回集合包含的位置元素当中， 与中心的距离不超过给定最大距离的所有位置元素</span></span><br><span class="line"><span class="comment">#WITHDIST：在返回位置元素的同时， 将位置元素与中心之间的距离也一并返回</span></span><br><span class="line"><span class="comment">#WITHCOORD：将位置元素的经度和维度也一并返回</span></span><br><span class="line"><span class="comment">#WITHHASH：以 52 位有符号整数的形式， 返回位置元素经过原始 geohash 编码的有序集合分值。这个选项主要用于底层应用或者调试， 实际中的作用并不大。</span></span><br><span class="line">GEORADIUSBYMEMBER key member radius		<span class="comment">#功能与GEORADIUS相同，只是中心位置不是具体的经纬度，而是使用已有的成员</span></span><br><span class="line">geohash key member1 [member..]		<span class="comment">#返回一个或多个位置元素的Geohash表示，使用Geohash位置52点整数编码</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="7-Hyperloglog（基数统计）"><a href="#7-Hyperloglog（基数统计）" class="headerlink" title="7. Hyperloglog（基数统计）"></a>7. Hyperloglog（基数统计）</h4><ul>
<li><p>底层使用string数据类型。</p>
</li>
<li><p>占用的内存是固定，2^64 不同的元素的技术，只需要废 12KB内存。</p>
</li>
<li><p>如果允许容错，那么一定可以使用Hyperloglog ，如果不允许容错，就使用set或者自己的数据类型即可。</p>
</li>
<li><p>使用场景：网页的访问量。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">PFADD key element1 [elememt2..]		<span class="comment">#添加指定元素到 HyperLogLog 中</span></span><br><span class="line">PFCOUNT key [key]		<span class="comment">#返回给定 HyperLogLog 的基数估算值</span></span><br><span class="line">PFMERGE destkey sourcekey [sourcekey..]		<span class="comment">#将多个 HyperLogLog 合并为一个 HyperLogLog</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="8-Bitmap（位图）"><a href="#8-Bitmap（位图）" class="headerlink" title="8. Bitmap（位图）"></a>8. Bitmap（位图）</h4><ul>
<li><p>使用位存储，信息状态只有 0 和 1。</p>
</li>
<li><p>Bitmap是一串连续的2进制数字（0或1），每一位所在的位置为偏移(offset)。</p>
</li>
<li><p>在bitmap上可执行AND,OR,XOR,NOT以及其它位操作。</p>
</li>
<li><p>使用场景：签到统计、状态统计，两个状态的，都可以使用 Bitmaps。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">setbit key offset value		<span class="comment">#为指定key的offset位设置值</span></span><br><span class="line">getbit key offset		<span class="comment">#获取offset位的值</span></span><br><span class="line">bitcount key [start end]		<span class="comment">#统计字符串被设置为1的bit数，也可以指定统计范围按字节</span></span><br><span class="line">bitop operration destkey key[key..]		<span class="comment">#对一个或多个保存二进制位的字符串 key 进行位元操作，并将结果保存到destkey上</span></span><br><span class="line">bitpos key bit [start] [end]		<span class="comment">#返回字符串里面第一个被设置为1或者0的bit位,start和end只能按字节,不能按位</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="四-事务"><a href="#四-事务" class="headerlink" title="四. 事务"></a>四. 事务</h3><h4 id="1-Redis-事务"><a href="#1-Redis-事务" class="headerlink" title="1. Redis 事务"></a>1. Redis 事务</h4><ul>
<li>Redis 事务可以一次执行多个命令， 并且带有以下三个重要的保证：<ul>
<li>批量操作在发送 EXEC 命令前被放入队列缓存。</li>
<li>收到 EXEC 命令后进入事务执行，事务中任意命令执行失败，其余的命令依然被执行。</li>
<li>在事务执行过程，其他客户端提交的命令请求不会插入到事务执行命令序列中。</li>
</ul>
</li>
<li>一个事务从开始到执行会经历以下三个阶段：<ul>
<li>开始事务（<strong>MULTI</strong> ）</li>
<li>命令入队</li>
<li>执行事务（<strong>EXEC</strong> ）</li>
</ul>
</li>
<li>单个 Redis 命令的执行是原子性的，但 Redis 没有在事务上增加任何维持原子性的机制，所以 Redis 事务的执行并不是原子性的。</li>
<li>编译型异常（代码有问题，命令有错），事务中所有的命令都不会被执行。</li>
<li>运行时异常（1 / 0），如果事务队列中存在语法性，那么执行命令的时候，其他命令是可以正常执行的，错误命令跑出异常。</li>
</ul>
<h4 id="2-事务命令"><a href="#2-事务命令" class="headerlink" title="2. 事务命令"></a>2. 事务命令</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">MULTI		<span class="comment">#标记一个事务块的开始</span></span><br><span class="line">DISCARD		<span class="comment">#取消事务，放弃执行事务块内的所有命令</span></span><br><span class="line">EXEC		<span class="comment">#执行所有事务块内的命令</span></span><br><span class="line">WATCH key [key ...]		<span class="comment">#监视一个(或多个) key ，如果在事务执行之前这个(或这些) key 被其他命令所改动，那么事务将被打断，导致事务执行失败，如果发现事务执行失败，就先解锁，在进行监视</span></span><br><span class="line">UNWATCH		<span class="comment">#取消 WATCH 命令对所有 key 的监视</span></span><br></pre></td></tr></table></figure>



<h4 id="3-实例"><a href="#3-实例" class="headerlink" title="3. 实例"></a>3. 实例</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">redis 127.0.0.1:6379&gt; MULTI</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">redis 127.0.0.1:6379&gt; SET name <span class="string">&quot;hello redis&quot;</span></span><br><span class="line">QUEUED</span><br><span class="line"></span><br><span class="line">redis 127.0.0.1:6379&gt; GET name</span><br><span class="line">QUEUED</span><br><span class="line"></span><br><span class="line">redis 127.0.0.1:6379&gt; SADD tag <span class="string">&quot;hello&quot;</span> <span class="string">&quot;redis&quot;</span></span><br><span class="line">QUEUED</span><br><span class="line"></span><br><span class="line">redis 127.0.0.1:6379&gt; SMEMBERS tag</span><br><span class="line">QUEUED</span><br><span class="line"></span><br><span class="line">redis 127.0.0.1:6379&gt; EXEC</span><br><span class="line">1) OK</span><br><span class="line">2) <span class="string">&quot;hello redis&quot;</span></span><br><span class="line">3) (<span class="built_in">integer</span>) 2</span><br><span class="line">4) 1) <span class="string">&quot;hello&quot;</span></span><br><span class="line">   2) <span class="string">&quot;redis&quot;</span></span><br></pre></td></tr></table></figure>





<h3 id="五-Jedis"><a href="#五-Jedis" class="headerlink" title="五. Jedis"></a>五. Jedis</h3><h4 id="1-Jedis-介绍"><a href="#1-Jedis-介绍" class="headerlink" title="1. Jedis 介绍"></a>1. Jedis 介绍</h4><ul>
<li><strong>Jedis</strong> 是 Redis 官方推荐的 java 连接开发工具，使用 java 操作 Redis 的中间件。</li>
</ul>
<h4 id="2-连接-redis-服务"><a href="#2-连接-redis-服务" class="headerlink" title="2. 连接 redis 服务"></a>2. 连接 redis 服务</h4><ul>
<li><p>导入依赖</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>redis.clients<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jedis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.2.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>连接</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestPing</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//连接本地的 Redis 服务</span></span><br><span class="line">        Jedis jedis = <span class="keyword">new</span> Jedis(<span class="string">&quot;localhost&quot;</span>,<span class="number">6379</span>);</span><br><span class="line">        <span class="comment">// 如果 Redis 服务设置了密码，需要下面这行，没有就不需要</span></span><br><span class="line">        <span class="comment">// jedis.auth(&quot;123456&quot;); </span></span><br><span class="line">        System.out.println(<span class="string">&quot;连接成功&quot;</span>);</span><br><span class="line">        <span class="comment">//查看服务是否运行</span></span><br><span class="line">        System.out.println(<span class="string">&quot;服务正在运行: &quot;</span>+jedis.ping());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>redis</category>
      </categories>
      <tags>
        <tag>数据类型</tag>
        <tag>事务</tag>
        <tag>jedis</tag>
      </tags>
  </entry>
  <entry>
    <title>redis进阶</title>
    <url>/post/d6c4a96f/</url>
    <content><![CDATA[<span id="more"></span>

<h3 id="一-发布订阅"><a href="#一-发布订阅" class="headerlink" title="一. 发布订阅"></a>一. 发布订阅</h3><h4 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1. 介绍"></a>1. 介绍</h4><ul>
<li><p>Redis 发布订阅 (pub/sub) 是一种消息通信模式：发送者 (pub) 发送消息，订阅者 (sub) 接收消息。</p>
</li>
<li><p>下图展示了频道 channel1 ， 以及订阅这个频道的三个客户端 —— client2 、 client5 和 client1 之间的关系：</p>
</li>
</ul>
<p><img data-src="https://www.runoob.com/wp-content/uploads/2014/11/pubsub1.png" alt="img"></p>
<ul>
<li>当有新消息通过 PUBLISH 命令发送给频道 channel1 时， 这个消息就会被发送给订阅它的三个客户端：</li>
</ul>
<p><img data-src="https://www.runoob.com/wp-content/uploads/2014/11/pubsub2.png" alt="img"></p>
<p>​                            <strong>注意</strong>：两个 redis-cli 客户端是同一个 redis 镜像开启的。</p>
<h4 id="2-Redis-发布订阅命令"><a href="#2-Redis-发布订阅命令" class="headerlink" title="2. Redis 发布订阅命令"></a>2. Redis 发布订阅命令</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">SUBSCRIBE channel [channel ...]		<span class="comment">#订阅给定的一个或多个频道的信息</span></span><br><span class="line">PUBLISH channel message		<span class="comment">#将信息发送到指定的频道</span></span><br><span class="line">UNSUBSCRIBE channel [channel ...]		<span class="comment">#退订给定的频道</span></span><br><span class="line">PSUBSCRIBE pattern [pattern ...]		<span class="comment">#订阅一个或多个符合给定模式的频道</span></span><br><span class="line">PUNSUBSCRIBE pattern [pattern ...]		<span class="comment">#退订所有给定模式的频道</span></span><br><span class="line">PUBSUB subcommand [argument [argument ...]]		<span class="comment">#查看订阅与发布系统状态</span></span><br></pre></td></tr></table></figure>



<h4 id="3-应用场景"><a href="#3-应用场景" class="headerlink" title="3.应用场景"></a>3.应用场景</h4><ul>
<li>今日头条订阅号、微信订阅公众号、新浪微博关注、邮件订阅系统</li>
<li>即时通信系统（QQ、微信）</li>
<li>群聊部落系统（微信群）</li>
</ul>
<h3 id="二-配置文件"><a href="#二-配置文件" class="headerlink" title="二. 配置文件"></a>二. 配置文件</h3><ul>
<li><p>在启动Redis服务器时,我们需要为其指定一个配置文件,缺省情况下配置文件在Redis的源码目录下,文件名为<strong>redis.conf。</strong></p>
</li>
<li><p>redis配置文件使用<code>#######################</code>被分成了几大块区域，主要有：</p>
<ul>
<li>通用(general)</li>
<li>快照(snapshotting)</li>
<li>复制(replication)</li>
<li>安全(security)</li>
<li>限制(limits)</li>
<li>追加模式(append only mode)</li>
<li>LUA脚本(lua scripting)</li>
<li>REDIS集群(REDIS CLUSTER)</li>
<li>慢日志(slow log)</li>
<li>事件通知(event notification)</li>
<li>ADVANCED CONFIG</li>
</ul>
</li>
<li><p>配置文件内容</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 当你需要为某个配置项指定内存大小的时候，必须要带上单位，</span></span><br><span class="line"><span class="comment"># 通常的格式就是 1k 5gb 4m 等酱紫：</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># 1k  =&gt; 1000 bytes</span></span><br><span class="line"><span class="comment"># 1kb =&gt; 1024 bytes</span></span><br><span class="line"><span class="comment"># 1m  =&gt; 1000000 bytes</span></span><br><span class="line"><span class="comment"># 1mb =&gt; 1024*1024 bytes</span></span><br><span class="line"><span class="comment"># 1g  =&gt; 1000000000 bytes</span></span><br><span class="line"><span class="comment"># 1gb =&gt; 1024*1024*1024 bytes</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># 单位是不区分大小写的，你写 1K 5GB 4M 也行</span></span><br><span class="line"></span><br><span class="line"><span class="comment">################################## INCLUDES ###################################</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 假如说你有一个可用于所有的 redis server 的标准配置模板，</span></span><br><span class="line"><span class="comment"># 但针对某些 server 又需要一些个性化的设置，</span></span><br><span class="line"><span class="comment"># 你可以使用 include 来包含一些其他的配置文件，这对你来说是非常有用的。</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># 但是要注意哦，include 是不能被 config rewrite 命令改写的</span></span><br><span class="line"><span class="comment"># 由于 redis 总是以最后的加工线作为一个配置指令值，所以你最好是把 include 放在这个文件的最前面，</span></span><br><span class="line"><span class="comment"># 以避免在运行时覆盖配置的改变，相反，你就把它放在后面（外国人真啰嗦）。</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># include /path/to/local.conf</span></span><br><span class="line"><span class="comment"># include /path/to/other.conf</span></span><br><span class="line"></span><br><span class="line"><span class="comment">################################ 常用 #####################################</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 默认情况下 redis 不是作为守护进程运行的，如果你想让它在后台运行，你就把它改成 yes。</span></span><br><span class="line"><span class="comment"># 当redis作为守护进程运行的时候，它会写一个 pid 到 /var/run/redis.pid 文件里面。</span></span><br><span class="line">daemonize no</span><br><span class="line"></span><br><span class="line"><span class="comment"># 当redis作为守护进程运行的时候，它会把 pid 默认写到 /var/run/redis.pid 文件里面，</span></span><br><span class="line"><span class="comment"># 但是你可以在这里自己制定它的文件位置。</span></span><br><span class="line">pidfile /var/run/redis.pid</span><br><span class="line"></span><br><span class="line"><span class="comment"># 监听端口号，默认为 6379，如果你设为 0 ，redis 将不在 socket 上监听任何客户端连接。</span></span><br><span class="line">port 6379</span><br><span class="line"></span><br><span class="line"><span class="comment"># TCP 监听的最大容纳数量</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># 在高并发的环境下，你需要把这个值调高以避免客户端连接缓慢的问题。</span></span><br><span class="line"><span class="comment"># Linux 内核会一声不响的把这个值缩小成 /proc/sys/net/core/somaxconn 对应的值，</span></span><br><span class="line"><span class="comment"># 所以你要修改这两个值才能达到你的预期。</span></span><br><span class="line">tcp-backlog 511</span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定在一个 client 空闲多少秒之后关闭连接（0 就是不管它）</span></span><br><span class="line">timeout 0</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义日志级别。</span></span><br><span class="line"><span class="comment"># 可以是下面的这些值：</span></span><br><span class="line"><span class="comment"># debug (适用于开发或测试阶段)</span></span><br><span class="line"><span class="comment"># verbose (many rarely useful info, but not a mess like the debug level)</span></span><br><span class="line"><span class="comment"># notice (适用于生产环境)</span></span><br><span class="line"><span class="comment"># warning (仅仅一些重要的消息被记录)</span></span><br><span class="line">loglevel notice</span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定日志文件的位置</span></span><br><span class="line">logfile <span class="string">&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置数据库的数目。</span></span><br><span class="line"><span class="comment"># 默认数据库是 DB 0，你可以在每个连接上使用 select &lt;dbid&gt; 命令选择一个不同的数据库，</span></span><br><span class="line"><span class="comment"># 但是 dbid 必须是一个介于 0 到 databasees - 1 之间的值</span></span><br><span class="line">databases 16</span><br><span class="line"></span><br><span class="line"><span class="comment">################################ 快照 ################################</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># 存 DB 到磁盘：</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#   格式：save &lt;间隔时间（秒）&gt; &lt;写入次数&gt;</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#   根据给定的时间间隔和写入次数将数据保存到磁盘</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#   下面的例子的意思是：</span></span><br><span class="line"><span class="comment">#   900 秒后如果至少有 1 个 key 的值变化，则保存</span></span><br><span class="line"><span class="comment">#   300 秒后如果至少有 10 个 key 的值变化，则保存</span></span><br><span class="line"><span class="comment">#   60 秒后如果至少有 10000 个 key 的值变化，则保存</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#   注意：你可以注释掉所有的 save 行来停用保存功能。</span></span><br><span class="line"><span class="comment">#   也可以直接一个空字符串来实现停用：</span></span><br><span class="line"><span class="comment">#   save &quot;&quot;</span></span><br><span class="line"></span><br><span class="line">save 900 1</span><br><span class="line">save 300 10</span><br><span class="line">save 60 10000</span><br><span class="line"></span><br><span class="line"><span class="comment"># 默认情况下，如果 redis 最后一次的后台保存失败，redis 将停止接受写操作，</span></span><br><span class="line"><span class="comment"># 这样以一种强硬的方式让用户知道数据不能正确的持久化到磁盘，</span></span><br><span class="line"><span class="comment"># 否则就会没人注意到灾难的发生。</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># 如果后台保存进程重新启动工作了，redis 也将自动的允许写操作。</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># 然而你要是安装了靠谱的监控，你可能不希望 redis 这样做，那你就改成 no 好了。</span></span><br><span class="line">stop-writes-on-bgsave-error yes</span><br><span class="line"></span><br><span class="line"><span class="comment"># 是否在 dump .rdb 数据库的时候使用 LZF 压缩字符串</span></span><br><span class="line"><span class="comment"># 默认都设为 yes</span></span><br><span class="line"><span class="comment"># 如果你希望保存子进程节省点 cpu ，你就设置它为 no ，</span></span><br><span class="line"><span class="comment"># 不过这个数据集可能就会比较大</span></span><br><span class="line">rdbcompression yes</span><br><span class="line"></span><br><span class="line"><span class="comment"># 是否校验rdb文件</span></span><br><span class="line">rdbchecksum yes</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置 dump 的文件位置</span></span><br><span class="line">dbfilename dump.rdb</span><br><span class="line"></span><br><span class="line"><span class="comment"># 工作目录</span></span><br><span class="line"><span class="comment"># 例如上面的 dbfilename 只指定了文件名，</span></span><br><span class="line"><span class="comment"># 但是它会写入到这个目录下。这个配置项一定是个目录，而不能是文件名。</span></span><br><span class="line">dir ./</span><br><span class="line"></span><br><span class="line"><span class="comment">################################# 主从复制 #################################</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 主从复制。使用 slaveof 来让一个 redis 实例成为另一个reids 实例的副本。</span></span><br><span class="line"><span class="comment"># 注意这个只需要在 slave 上配置。</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># slaveof &lt;masterip&gt; &lt;masterport&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果 master 需要密码认证，就在这里设置</span></span><br><span class="line"><span class="comment"># masterauth &lt;master-password&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 当一个 slave 与 master 失去联系，或者复制正在进行的时候，</span></span><br><span class="line"><span class="comment"># slave 可能会有两种表现：</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># 1) 如果为 yes ，slave 仍然会应答客户端请求，但返回的数据可能是过时，</span></span><br><span class="line"><span class="comment">#    或者数据可能是空的在第一次同步的时候</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># 2) 如果为 no ，在你执行除了 info he salveof 之外的其他命令时，</span></span><br><span class="line"><span class="comment">#    slave 都将返回一个 &quot;SYNC with master in progress&quot; 的错误，</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line">slave-serve-stale-data yes</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Slaves 在一个预定义的时间间隔内发送 ping 命令到 server 。</span></span><br><span class="line"><span class="comment"># 你可以改变这个时间间隔。默认为 10 秒。</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># repl-ping-slave-period 10</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置主从复制过期时间</span></span><br><span class="line"><span class="comment"># 这个值一定要比 repl-ping-slave-period 大</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># repl-timeout 60</span></span><br><span class="line"></span><br><span class="line"><span class="comment">################################## 安全 ###################################</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置客户端连接后进行任何其他指定前需要使用的密码</span></span><br><span class="line"><span class="comment"># requirepass foobared</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Command renaming.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># 命令重命名,在一个共享环境下可以重命名相对危险的命令,比如把CONFIG重名为一个不容易猜测的字符: rename-command CONFIG 	   # b840fc02d524045429941cc15f59e41cb7be6c52。 如果想删除一个命令,直接把它重命名为一个空字符&quot;&quot;即可:rename-command  # CONFIG &quot;&quot;;</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># rename-command CONFIG &quot;&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">################################### 限制 ####################################</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置最多同时连接客户端数量</span></span><br><span class="line"><span class="comment"># 特殊值&quot;0&quot;表示没有限制</span></span><br><span class="line"><span class="comment"># 一旦达到最大限制，redis 将关闭所有的新连接</span></span><br><span class="line"><span class="comment"># 并发送一个‘max number of clients reached’的错误。</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># maxclients 10000</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果你设置了这个值，当缓存的数据容量达到这个值， redis 将根据你选择的 eviction 策略来移除一些 keys。</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Redis在启动时会把数据加载到内存中,达到最大内存后,Redis会先尝试清除已到期或即将到期的Key, Redis同时也会移除空的list对   # 象。当此方法处理后,仍然到达最大内存设置,将无法再进行写入操作,但仍然可以进行读取操作。</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># 最大使用内存</span></span><br><span class="line"><span class="comment"># maxmemory &lt;bytes&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 最大内存策略，你有 5 个选择。</span></span><br><span class="line"><span class="comment"># </span></span><br><span class="line"><span class="comment"># volatile-lru 代表利用LRU算法移除设置过期时间的key(LRU:最近使用 LeastRecentlyUsed)</span></span><br><span class="line"><span class="comment"># allkeys-lru 代表利用LRU算法移除任何key</span></span><br><span class="line"><span class="comment"># volatile-random 代表移除设置过过期时间的随机key</span></span><br><span class="line"><span class="comment"># allkeys_random 代表移除一个随机的key,</span></span><br><span class="line"><span class="comment"># volatile-ttl 代表移除即将过期的key(minor TTL)</span></span><br><span class="line"><span class="comment"># noeviction 代表不移除任何key,只是返回一个写错误。</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># The default is:</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># maxmemory-policy noeviction</span></span><br><span class="line"></span><br><span class="line"><span class="comment">############################## APPEND ONLY MODE ###############################</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#是否开启aof功能</span></span><br><span class="line">appendonly no</span><br><span class="line"></span><br><span class="line"><span class="comment"># The name of the append only file (default: &quot;appendonly.aof&quot;)</span></span><br><span class="line">appendfilename <span class="string">&quot;appendonly.aof&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#Redis支持三种同步AOF文件的策略:</span></span><br><span class="line"><span class="comment"># no 代表不进行同步,系统去操作,</span></span><br><span class="line"><span class="comment"># always 代表每次有写操作都进行同步,</span></span><br><span class="line"><span class="comment"># everysec 代表对写操作进行累积,每秒同步一次</span></span><br><span class="line"><span class="comment"># 默认是&quot;everysec&quot;,按照速度和安全折中这是最好的。</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># appendfsync always</span></span><br><span class="line">appendfsync everysec</span><br><span class="line"><span class="comment"># appendfsync no</span></span><br><span class="line"></span><br><span class="line"><span class="comment">################################## SLOW LOG ###################################</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 记录超过特定执行时间的命令。执行时间不包括I/O计算,比如连接客户端,返回结果等,只是命令执行时间。</span></span><br><span class="line"><span class="comment"># 可以通过两个参数设置slow log:一个是告诉Redis执行超过多少时间被记录的参数slowlog-log-slower-than(微妙), 另一个是slow # log 的长度。当一个新命令被记录的时候最早的命令将被从队列中移除</span></span><br><span class="line"><span class="comment"># 注意制定一个负数将关闭慢日志,而设置为0将强制每个命令都会记录</span></span><br><span class="line">slowlog-log-slower-than 10000</span><br><span class="line"></span><br><span class="line"><span class="comment"># 慢操作日志&quot;保留的最大条数</span></span><br><span class="line"><span class="comment"># 记录&quot;将会被队列化,如果超过了此长度,旧记录将会被移除。可以通过SLOWLOG &lt;subcommand&gt; args查看慢记录的信息(SLOWLOG get # 10,SLOWLOG reset)，通过&quot;SLOWLOG get num&quot;指令可以查看最近num条慢速记录，其中包括&quot;记录&quot;操作的时间/指令/K-V等信息。</span></span><br><span class="line">slowlog-max-len 128</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="三-持久化"><a href="#三-持久化" class="headerlink" title="三. 持久化"></a>三. 持久化</h3><h4 id="1-介绍-1"><a href="#1-介绍-1" class="headerlink" title="1. 介绍"></a>1. 介绍</h4><ul>
<li>目前Redis持久化的方式有两种： RDB 和 AOF。</li>
<li>持久化的数据是用于重启后的数据恢复。</li>
<li>Redis是一个内存数据库，无论是RDB还是AOF，都是其保证数据恢复的措施。所以Redis在利用RDB和AOF进行恢复的时候，都会读取RDB或AOF文件，重新加载到内存中。</li>
</ul>
<h4 id="2-RDB（Redis-DataBase）"><a href="#2-RDB（Redis-DataBase）" class="headerlink" title="2. RDB（Redis DataBase）"></a>2. RDB（Redis DataBase）</h4><ul>
<li><p>RDB就是Snapshot快照存储，是默认的持久化方式。即按照一定的策略周期性的将数据保存到磁盘， 对应产生的数据文件为dump.rdb，快照的周期通过配置文件中的save参数来定义。</p>
<p>默认的快照设置：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">dbfilename dump.rdb</span><br><span class="line"><span class="comment"># save &lt;seconds&gt; &lt;changes&gt;</span></span><br><span class="line">save 900 1    <span class="comment">#当有一条Keys数据被改变时，900秒刷新到Disk一次</span></span><br><span class="line">save 300 10   <span class="comment">#当有10条Keys数据被改变时，300秒刷新到Disk一次</span></span><br><span class="line">save 60 10000 <span class="comment">#当有10000条Keys数据被改变时，60秒刷新到Disk一次</span></span><br></pre></td></tr></table></figure>

<p>Redis的RDB文件不会坏掉，因为其写操作是在一个新进程中进行的。 当生成一个新的RDB文件时，Redis生成的子进程会先将数据写到一个临时文件中，然后通过原子性rename系统调用将临时文件重命名为RDB文件。</p>
<p>这样在任何时候出现故障，Redis的RDB文件都总是可用的。</p>
<p>同时，Redis的RDB文件也是Redis主从同步内部实现中的一环。</p>
<ul>
<li><p>第一次Slave向Master同步的实现是： Slave向Master发出同步请求，Master先dump出rdb文件，然后将rdb文件全量传输给slave，然后Master把缓存的命令转发给Slave，初次同步完成。</p>
</li>
<li><p>第二次以及以后的同步实现是： Master将变量的快照直接实时依次发送给各个Slave。 但不管什么原因导致Slave和Master断开重连都会重复以上两个步骤的过程。</p>
</li>
</ul>
<p>Redis的主从复制是建立在内存快照的持久化基础上的，只要有Slave就一定会有内存快照发生。可以很明显的看到，RDB有它的不足，就是一旦数据库出现问题，那么我们的RDB文件中保存的数据并不是全新的。</p>
<p>从上次RDB文件生成到Redis停机这段时间的数据全部丢掉了。</p>
</li>
</ul>
<h4 id="3-AOF（Append-Only-File）"><a href="#3-AOF（Append-Only-File）" class="headerlink" title="3. AOF（Append-Only File）"></a>3. AOF（Append-Only File）</h4><ul>
<li><p>在使用AOF持久化方式时，Redis会将每一个收到的 <strong>写</strong> 命令都通过Write函数追加到文件。</p>
</li>
<li><p>当Redis重启是会通过重新执行文件中保存的写命令来在内存中重建整个数据库的内容。</p>
<ul>
<li>在Redis重启时会逐个执行AOF文件中的命令来将硬盘中的数据载入到内存中,所以说，载入的速度相较RDB会慢一些。</li>
</ul>
</li>
<li><p>默认情况下,Redis没有开启AOF方式的持久化,可以在redis.conf中通过<code>appendonly</code>参数开启:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">appendonly yes         <span class="comment">#启用aof持久化方式</span></span><br><span class="line"><span class="comment"># appendfsync always   #每次收到写命令就立即强制写入磁盘，最慢的，但是保证完全的持久化，不推荐使用</span></span><br><span class="line">appendfsync everysec     <span class="comment">#每秒钟强制写入磁盘一次，在性能和持久化方面做了很好的折中，推荐</span></span><br><span class="line"><span class="comment"># appendfsync no #完全依赖OS的写入，一般为30秒左右一次，性能最好但是持久化最没有保证，不被推荐。</span></span><br></pre></td></tr></table></figure></li>
<li><p>AOF文件和 RDB文件的保存文件夹位置相同,都是通过dir参数设置的,默认的文件名是<code>appendonly.aof</code>,可以通过<code>appendfilename</code>参数修改。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">appendfilename appendonly.aof</span><br></pre></td></tr></table></figure></li>
<li><p>AOF的完全持久化方式同时也带来了另一个问题，持久化文件会变得越来越大。</p>
<p>配置redis自动重写AOF文件的参数</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">no-appendfsync-on-rewrite yes   <span class="comment">#在AOF重写时，不进行命令追加操作，而只是将其放在缓冲区里，避免与命令的追加造成`DISK IO`上的冲突。</span></span><br><span class="line">auto-aof-rewrite-percentage 100 <span class="comment">#当前AOF文件大小是上次日志重写得到AOF文件大小的二倍时，自动启动新的日志重写过程。</span></span><br><span class="line">auto-aof-rewrite-min-size 64mb <span class="comment">#当前AOF文件启动新的日志重写过程的最小值，避免刚刚启动Reids时由于文件尺寸较小导致频繁的重写。</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="四-主从复制"><a href="#四-主从复制" class="headerlink" title="四. 主从复制"></a>四. 主从复制</h3><h4 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h4><ul>
<li>主从复制，是指将一台Redis服务器的数据，复制到其他的Redis服务器。前者称为主节点(master)，后者称为从节点(slave)；数据的复制是单向的，只能由主节点到从节点。</li>
<li>主从复制的作用主要包括：<ul>
<li>据冗余：主从复制实现了数据的热备份，是持久化之外的一种数据冗余方式。</li>
<li>故障恢复：当主节点出现问题时，可以由从节点提供服务，实现快速的故障恢复；实际上是一种服务的冗余。</li>
<li>负载均衡：在主从复制的基础上，配合读写分离，可以由主节点提供写服务，由从节点提供读服务（即写Redis数据时应用连接主节点，读Redis数据时应用连接从节点），分担服务器负载；尤其是在写少读多的场景下，通过多个从节点分担读负载，可以大大提高Redis服务器的并发量。</li>
<li>高可用基石：除了上述作用以外，主从复制还是哨兵和集群能够实施的基础，因此说主从复制是Redis高可用的基础。</li>
</ul>
</li>
</ul>
<h4 id="2-主从复制命令"><a href="#2-主从复制命令" class="headerlink" title="2. 主从复制命令"></a>2. 主从复制命令</h4><ul>
<li><p>主从复制的开启，完全是在从节点发起的；不需要我们在主节点做任何事情。</p>
</li>
<li><p>从节点开启主从复制，有3种方式：</p>
<ul>
<li><p>配置文件</p>
<p>在从服务器的配置文件中加入：slaveof <masterip> <masterport></masterport></masterip></p>
</li>
<li><p>启动命令</p>
<p>redis-server启动命令后加入 –slaveof <masterip> <masterport></masterport></masterip></p>
</li>
<li><p>客户端命令</p>
<p>Redis服务器启动后，直接通过客户端执行命令：slaveof <masterip> <masterport>，则该Redis实例成为从节点</masterport></masterip></p>
</li>
</ul>
</li>
<li><p>可以通过 <strong>slaveof no one</strong> 断开。需要注意的是，从节点断开复制后，不会删除已有的数据，只是不再接受主节点新的数据变化。</p>
</li>
</ul>
<h4 id="3-原理"><a href="#3-原理" class="headerlink" title="3. 原理"></a>3. 原理</h4><p>​        主从复制过程大体可以分为3个阶段：连接建立阶段（即准备阶段）、数据同步阶段、命令传播阶段。</p>
<pre><code>##### 3.1 连接建立阶段
</code></pre>
<ul>
<li><p><strong>保存主节点信息</strong></p>
<p>从节点服务器内部维护了两个字段，即 masterhost 和 masterport 字段，用于存储主节点的 ip 和 port 信息。</p>
<p>需要注意的是， slaveof 是异步命令，从节点完成主节点 ip 和 port 的保存后，向发送 slaveof 命令的客户端直接返回 OK ，实际的复制操作在这之后才开始进行。</p>
</li>
<li><p><strong>建立 socket 连接</strong></p>
<p>从节点每秒1次调用复制定时函数 replicationCron() ，如果发现了有主节点可以连接，便会根据主节点的 ip 和 port ，创建 socket 连接。如果连接成功，则：</p>
<ul>
<li><p>从节点：为该 socket 建立一个专门处理复制工作的文件事件处理器，负责后续的复制工作，如接收 RDB 文件、接收命令传播等。</p>
</li>
<li><p>主节点：接收到从节点的 socket 连接后（即 accept 之后），为该socket创建相应的客户端状态，并将从节点看做是连接到主节点的一个客户端，后面的步骤会以从节点向主节点发送命令请求的形式来进行。</p>
</li>
</ul>
</li>
<li><p><strong>发送 ping 命令</strong></p>
<p>从节点成为主节点的客户端之后，发送 ping 命令进行首次请求，目的是：检查 socket 连接是否可用，以及主节点当前是否能够处理请求。</p>
<p>从节点发送 ping 命令后，可能出现3种情况：</p>
<ul>
<li><p>返回 pong ：说明 socket 连接正常，且主节点当前可以处理请求，复制过程继续。</p>
</li>
<li><p>超时：一定时间后从节点仍未收到主节点的回复，说明 socket 连接不可用，则从节点断开 socket 连接，并重连。</p>
</li>
<li><p>返回 pong 以外的结果：如果主节点返回其他结果，如正在处理超时运行的脚本，说明主节点当前无法处理命令，则从节点断开  socket 连接，并重连。</p>
</li>
</ul>
</li>
<li><p><strong>身份验证</strong></p>
</li>
<li><p><strong>发送从节点端口信息</strong></p>
<p>身份验证之后，从节点会向主节点发送其监听的端口号，主节点将该信息保存到该从节点对应的客户端的 slave_listening_port 字段中；该端口信息除了在主节点中执行 info Replication 时显示以外，没有其他作用。</p>
</li>
</ul>
<h5 id="3-2-数据同步阶段"><a href="#3-2-数据同步阶段" class="headerlink" title="3.2 数据同步阶段"></a>3.2 数据同步阶段</h5><ul>
<li>主从节点之间的连接建立以后，便可以开始进行数据同步，该阶段可以理解为从节点数据的初始化。具体执行的方式是：从节点向主节点发送 psync 命令（Redis2.8以前是 sync 命令），开始同步。</li>
<li>数据同步阶段是主从复制最核心的阶段，根据主从节点当前状态的不同，可以分为<strong>全量复制</strong>和<strong>部分复制</strong>。</li>
<li>需要注意的是，在数据同步阶段之前，从节点是主节点的客户端，主节点不是从节点的客户端；而到了这一阶段及以后，主从节点互为客户端。原因在于：在此之前，主节点只需要响应从节点的请求即可，不需要主动发请求，而在数据同步阶段和后面的命令传播阶段，主节点需要主动向从节点发送请求（如推送缓冲区中的写命令），才能完成复制。</li>
</ul>
<h5 id="3-3-命令传播阶段"><a href="#3-3-命令传播阶段" class="headerlink" title="3.3 命令传播阶段"></a>3.3 命令传播阶段</h5><ul>
<li>数据同步阶段完成后，主从节点进入命令传播阶段；在这个阶段主节点将自己执行的写命令发送给从节点，从节点接收命令并执行，从而保证主从节点数据的一致性。</li>
<li>在命令传播阶段，除了发送写命令，主从节点还维持着心跳机制：PING 和 REPLCONF ACK ，心跳机制的原理涉及部分复制。</li>
<li>需要注意的是，命令传播是异步的过程，即主节点发送写命令后并不会等待从节点的回复；因此实际上主从节点之间很难保持实时的一致性，延迟在所难免。数据不一致的程度，与主从节点之间的网络状况、主节点写命令的执行频率、以及主节点中的 repl-disable-tcp-nodelay 配置等有关。</li>
</ul>
<h4 id="4-全量复制和部分复制"><a href="#4-全量复制和部分复制" class="headerlink" title="4. 全量复制和部分复制"></a>4. 全量复制和部分复制</h4><p>​        sync 命令请求同步数据，此时的同步方式是全量复制；psync 命令请求同步数据，此时根据主从节点当前状态的不同，同步方式可能是全量复制或部分复制。</p>
<ul>
<li><p>全量复制：用于初次复制或其他无法进行部分复制的情况，将主节点中的所有数据都发送给从节点，是一个非常重型的操作。</p>
</li>
<li><p>部分复制：用于网络中断等情况后的复制，只将中断期间主节点执行的写命令发送给从节点，与全量复制相比更加高效。需要注意的是，如果网络中断时间过长，导致主节点没有能够完整地保存中断期间执行的写命令，则无法进行部分复制，仍使用全量复制。</p>
</li>
</ul>
<h3 id="五-哨兵模式"><a href="#五-哨兵模式" class="headerlink" title="五. 哨兵模式"></a>五. 哨兵模式</h3><h4 id="1-作用"><a href="#1-作用" class="headerlink" title="1. 作用"></a>1. 作用</h4><p>Redis Sentinel，即Redis哨兵，在Redis 2.8版本开始引入，<strong>哨兵的核心功能是主节点的自动故障转移。</strong></p>
<ul>
<li>监控（Monitoring）：哨兵会不断地检查主节点和从节点是否运作正常。</li>
<li>自动故障转移（Automatic failover）：当主节点不能正常工作时，哨兵会开始自动故障转移操作，它会将失效主节点的其中一个从节点升级为新的主节点，并让其他从节点改为复制新的主节点。</li>
<li>配置提供者（Configuration provider）：客户端在初始化时，通过连接哨兵来获得当前Redis服务的主节点地址。</li>
<li>通知（Notification）：哨兵可以将故障转移的结果发送给客户端。</li>
</ul>
<p>其中，监控和自动故障转移功能，使得哨兵可以及时发现主节点故障并完成转移；而配置提供者和通知功能，则需要在与客户端的交互中才能体现。</p>
<h4 id="2-架构"><a href="#2-架构" class="headerlink" title="2. 架构"></a>2. 架构</h4><p><img data-src="https://images2018.cnblogs.com/blog/1174710/201809/1174710-20180908182924632-1069251418.png" alt="哨兵"></p>
<p>它由两部分组成，哨兵节点和数据节点：</p>
<ul>
<li>哨兵节点：哨兵系统由一个或多个哨兵节点组成，哨兵节点是特殊的redis节点，不存储数据。</li>
<li>数据节点：主节点和从节点都是数据节点。</li>
</ul>
<h4 id="3-Docker-搭建-Redis-一主两从三哨兵"><a href="#3-Docker-搭建-Redis-一主两从三哨兵" class="headerlink" title="3. Docker 搭建 Redis 一主两从三哨兵"></a>3. Docker 搭建 Redis 一主两从三哨兵</h4><ul>
<li><p>获取并修改 redis 配置文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wget http://download.redis.io/redis-stable/redis.conf</span><br></pre></td></tr></table></figure>

<p>通过wget工具下载下来。我用的root用户，就直接下载到/root目录里了。</p>
</li>
</ul>
<h5 id="3-1-部署从节点"><a href="#3-1-部署从节点" class="headerlink" title="3.1 部署从节点"></a>3.1 部署从节点</h5><ul>
<li><p>对于master而言，配置文件修改以下几项</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 注释这一行，表示Redis可以接受任意ip的连接</span></span><br><span class="line"><span class="comment"># bind 127.0.0.1 </span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 关闭保护模式</span></span><br><span class="line">protected-mode no </span><br><span class="line"></span><br><span class="line"><span class="comment"># 让redis服务后台运行</span></span><br><span class="line">daemonize yes </span><br><span class="line"></span><br><span class="line"><span class="comment"># 设定密码(可选，如果这里开启了密码要求，slave的配置里就要加这个密码. 只是练习配置，就不使用密码认证了)</span></span><br><span class="line"><span class="comment"># requirepass masterpassword </span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 配置日志路径，为了便于排查问题，指定redis的日志文件目录</span></span><br><span class="line">logfile <span class="string">&quot;/var/log/redis/redis.log&quot;</span></span><br></pre></td></tr></table></figure></li>
<li><p>对于slave而言，配置文件修改以下几项</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 注释这一行，表示Redis可以接受任意ip的连接</span></span><br><span class="line"><span class="comment"># bind 127.0.0.1 </span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 关闭保护模式</span></span><br><span class="line">protected-mode no </span><br><span class="line"></span><br><span class="line"><span class="comment"># 让redis服务后台运行</span></span><br><span class="line">daemonize yes </span><br><span class="line"></span><br><span class="line"><span class="comment"># 设定密码(可选，如果这里开启了密码要求，slave的配置里就要加这个密码)</span></span><br><span class="line"><span class="comment">#requirepass masterpassword </span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 设定主库的密码，用于认证，如果主库开启了requirepass选项这里就必须填相应的密码</span></span><br><span class="line"><span class="comment">#masterauth &lt;master-password&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 设定master的IP和端口号，redis配置文件中的默认端口号是6379</span></span><br><span class="line"><span class="comment"># 低版本的redis这里会是slaveof，意思是一样的，因为slave是比较敏感的词汇，所以在redis后面的版本中不在使用slave的概念，取而代之的是replica</span></span><br><span class="line"><span class="comment"># 将35.236.172.131做为主，其余两台机器做从。ip和端口号按照机器和配置做相应修改。</span></span><br><span class="line">replicaof 35.236.172.131 6379</span><br><span class="line"></span><br><span class="line"><span class="comment"># 配置日志路径，为了便于排查问题，指定redis的日志文件目录</span></span><br><span class="line">logfile <span class="string">&quot;/var/log/redis/redis.log&quot;</span></span><br></pre></td></tr></table></figure></li>
<li><p>启动容器</p>
</li>
</ul>
<h3 id="六-Redis-缓存问题"><a href="#六-Redis-缓存问题" class="headerlink" title="六. Redis 缓存问题"></a>六. Redis 缓存问题</h3><h4 id="1-缓存雪崩"><a href="#1-缓存雪崩" class="headerlink" title="1. 缓存雪崩"></a>1. 缓存雪崩</h4><h5 id="1-1-概述"><a href="#1-1-概述" class="headerlink" title="1.1 概述"></a>1.1 概述</h5><p>​        如果缓存在某一个时刻出现大规模的key失效，也就是缓存集中过期失效，那么就会导致大量的请求打在了数据库上面，导致数据库压力巨大，如果在高并发的情况下，可能瞬间就会导致数据库宕机。</p>
<h5 id="1-2-问题探究"><a href="#1-2-问题探究" class="headerlink" title="1.2 问题探究"></a>1.2 问题探究</h5><p>​        造成缓存雪崩的关键在于同一时间的大规模的key失效，为什么会出现这个问题，主要有两种可能：第一种是Redis宕机，第二种可能就是采用了相同的过期时间。</p>
<h5 id="1-3-解决方法"><a href="#1-3-解决方法" class="headerlink" title="1.3 解决方法"></a>1.3 解决方法</h5><ul>
<li>缓存雪崩发生前<ul>
<li>均匀过期：设置不同的过期时间，让缓存失效的时间尽量均匀，避免相同的过期时间导致缓存雪崩，造成大量数据库的访问。</li>
<li> 分级缓存：第一级缓存失效的基础上，访问二级缓存，每一级缓存的失效时间都不同。</li>
<li> 热点数据缓存永远不过期。<strong>永不过期</strong>实际包含两层意思：</li>
<li>物理不过期，针对热点 key 不设置过期时间</li>
<li>逻辑过期，把过期时间存在 key 对应的 value 里，如果发现要过期了，通过一个后台的异步线程进行缓存的构建</li>
<li>保证 Redis 缓存的高可用，防止 Redis 宕机导致缓存雪崩的问题。可以使用 主从复制加哨兵，Redis 集群来避免 Redis 全盘崩溃的情况。</li>
</ul>
</li>
<li>缓存雪崩发生中<ul>
<li>互斥锁：在缓存失效后，通过互斥锁或者队列来控制读数据写缓存的线程数量，比如某个key只允许一个线程查询数据和写缓存，其他线程等待。这种方式会阻塞其他的线程，此时系统的吞吐量会下降。</li>
<li>使用熔断机制，限流降级。当流量达到一定的阈值，直接返回“系统拥挤”之类的提示，防止过多的请求打在数据库上将数据库击垮，至少能保证一部分用户是可以正常使用，其他用户多刷新几次也能得到结果。</li>
</ul>
</li>
<li>缓存雪崩发生后<ul>
<li>开启Redis持久化机制，尽快恢复缓存数据，一旦重启，就能从磁盘上自动加载数据恢复内存中的数据。</li>
</ul>
</li>
</ul>
<h4 id="2-缓存击穿"><a href="#2-缓存击穿" class="headerlink" title="2. 缓存击穿"></a>2. 缓存击穿</h4><h5 id="2-1-概述"><a href="#2-1-概述" class="headerlink" title="2.1 概述"></a>2.1 概述</h5><p>​        缓存击穿跟缓存雪崩有点类似，缓存雪崩是大规模的key失效，而缓存击穿是某个热点的key失效，大并发集中对其进行请求，就会造成大量请求读缓存没读到数据，从而导致高并发访问数据库，引起数据库压力剧增。这种现象就叫做缓存击穿。</p>
<h5 id="2-2-问题探究"><a href="#2-2-问题探究" class="headerlink" title="2.2 问题探究"></a>2.2 问题探究</h5><p>​        关键在于某个热点的key失效了，导致大并发集中打在数据库上。所以要从两个方面解决，第一是否可以考虑热点key不设置过期时间，第二是否可以考虑降低打在数据库上的请求数量。</p>
<h5 id="2-3-解决方法"><a href="#2-3-解决方法" class="headerlink" title="2.3 解决方法"></a>2.3 解决方法</h5><ul>
<li>在缓存失效后，通过互斥锁或者队列来控制读数据写缓存的线程数量，比如某个key只允许一个线程查询数据和写缓存，其他线程等待。这种方式会阻塞其他的线程，此时系统的吞吐量会下降。</li>
<li>热点数据缓存永远不过期。</li>
</ul>
<h4 id="3-缓存穿透"><a href="#3-缓存穿透" class="headerlink" title="3. 缓存穿透"></a>3. 缓存穿透</h4><h5 id="3-1-概述"><a href="#3-1-概述" class="headerlink" title="3.1 概述"></a>3.1 概述</h5><p>​        缓存穿透是指用户请求的数据在缓存中不存在即没有命中，同时在数据库中也不存在，导致用户每次请求该数据都要去数据库中查询一遍。如果有恶意攻击者不断请求系统中不存在的数据，会导致短时间大量请求落在数据库上，造成数据库压力过大，甚至导致数据库承受不住而宕机崩溃。</p>
<h5 id="3-2-问题探究"><a href="#3-2-问题探究" class="headerlink" title="3.2 问题探究"></a>3.2 问题探究</h5><p>​        缓存穿透的关键在于在 Redis 中查不到 key 值，它和缓存击穿的根本区别在于传进来的 key 在 Redis 中是不存在的。假如有黑客传进大量的不存在的 key ，那么大量的请求打在数据库上是很致命的问题，所以在日常开发中要对参数做好校验，一些非法的参数，不可能存在的 key 就直接返回错误提示。</p>
<p><img data-src="https://img-blog.csdnimg.cn/2021013117512340.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2E3NDUyMzM3MDA=,size_16,color_FFFFFF,t_70" alt="img"></p>
<h5 id="3-3-解决方法"><a href="#3-3-解决方法" class="headerlink" title="3.3 解决方法"></a>3.3 解决方法</h5><ul>
<li><p>将无效的key存放进Redis中</p>
<p>当出现Redis查不到数据，数据库也查不到数据的情况，我们就把这个 key 保存到 Redis 缓存中，设置 value=”null” ，并设置其过期时间极短，后面再出现查询这个 key 的请求的时候，直接返回 null ，就不需要再查询数据库了。但这种处理方式是有问题的，假如传进来的这个不存在的Key值每次都是随机的，那存进Redis也没有意义。</p>
</li>
<li><p>使用布隆过滤器</p>
<p>如果布隆过滤器判定某个 key 不存在于    布隆过滤器中，那么就一定不存在，如果判定某个 key 存在，那么很大可能是存在(存在一定的误判率)。于是我们可以在缓存之前再加一个布隆过滤器，将数据库中的所有key都存储在布隆过滤器中，在查询Redis前先去布隆过滤器查询 key 是否存在，如果不存在就直接返回，不让其访问数据库，从而避免了对底层存储系统的查询压力。</p>
<p><img data-src="https://img-blog.csdnimg.cn/2021013117514929.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2E3NDUyMzM3MDA=,size_16,color_FFFFFF,t_70" alt="img"></p>
</li>
</ul>
<h5 id="3-4-如何选择"><a href="#3-4-如何选择" class="headerlink" title="3.4 如何选择"></a>3.4 如何选择</h5><p>​        针对一些恶意攻击，攻击带过来的大量key是随机，那么我们采用第一种方案就会缓存大量不存在key的数据。那么这种方案就不合适了，我们可以先对使用布隆过滤器方案进行过滤掉这些key。所以，针对这种key异常多、请求重复率比较低的数据，优先使用第二种方案直接过滤掉。而对于空数据的key有限的，重复率比较高的，则可优先采用第一种方式进行缓存。</p>
<h4 id="4-缓存预热"><a href="#4-缓存预热" class="headerlink" title="4. 缓存预热"></a>4. 缓存预热</h4><h5 id="4-1-概述"><a href="#4-1-概述" class="headerlink" title="4.1 概述"></a>4.1 概述</h5><p>​        缓存预热是指系统上线后，提前将相关的缓存数据加载到缓存系统。避免在用户请求的时候，先查询数据库，然后再将数据缓存的问题，用户直接查询事先被预热的缓存数据。</p>
<p>​        如果不进行预热，那么Redis初始状态数据为空，系统上线初期，对于高并发的流量，都会访问到数据库中， 对数据库造成流量的压力。</p>
<h5 id="4-2-解决方法"><a href="#4-2-解决方法" class="headerlink" title="4.2 解决方法"></a>4.2 解决方法</h5><ul>
<li><p>数据量不大的时候，工程启动的时候进行加载缓存动作；</p>
</li>
<li><p>数据量大的时候，设置一个定时任务脚本，进行缓存的刷新；</p>
</li>
<li><p>数据量太大的时候，优先保证热点数据进行提前加载到缓存。</p>
</li>
</ul>
<h4 id="5-缓存降级"><a href="#5-缓存降级" class="headerlink" title="5.缓存降级"></a>5.缓存降级</h4><p>​        缓存降级是指缓存失效或缓存服务器挂掉的情况下，不去访问数据库，直接返回默认数据或访问服务的内存数据。降级一般是有损的操作，所以尽量减少降级对于业务的影响程度。</p>
<p>​        在项目实战中通常会将部分热点数据缓存到服务的内存中，这样一旦缓存出现异常，可以直接使用服务的内存数据，从而避免数据库遭受巨大压力。</p>
]]></content>
      <categories>
        <category>redis</category>
      </categories>
      <tags>
        <tag>数据类型</tag>
        <tag>事务</tag>
        <tag>jedis</tag>
        <tag>持久化(aof、rdb)</tag>
        <tag>主从复制</tag>
        <tag>哨兵模式</tag>
        <tag>缓存雪崩等</tag>
      </tags>
  </entry>
</search>
